#include <iostream>
#include <string>
#include <ctime>
#include <unistd.h>
#include <cmath>
#include <climits>
#include <map>
#include <unordered_map>
//#include <hash_map>
#include <thread>

#define 使用 using
#define 命名空间 namespace
使用 命名空间 std;
#define 整数 int
#define 主函数 main
#define 读 cin
#define 写 cout
#define 返回 return
#define 如果 if
#define 否则 else
#define 真 true
#define 假 false
#define 无类型 void
#define 常量 const
#define 有符号 signed
#define 无符号 unsigned
//typedef char 字节;
#define 字节 int8_t
#define 正字节 uint8_t
//typedef string 字符串;
#define 字符串 string

#define 模板 template
#define 类 class
/*
   模板 <类 数字>
   数字 绝对值(数字 数) {
   返回 数<0 ? -数 : 数;
   }*/
#define 绝对值(数) ((数)<0 ? -(数) : (数))
#define 最大(甲,乙) ((甲)>(乙) ? (甲) : (乙))
#define 最小(甲,乙) ((甲)<(乙) ? (甲) : (乙))

#define 等待回车() cin.get();

#ifdef _WIN32
#include <windows.h>
#endif
常量 字符串 横="一",  竖="丨",
红= "\e[31m",
黄= "\e[33m",
蓝= "\e[34m",
绿= "\e[32m";
string 彩字(string 颜色码,string 字符)
{
    返回 颜色码+字符+"\e[0m" ;
}
#define 红字(字) 彩字(红,字)
#define 黄字(字) 彩字(黄,字)
#define 蓝字(字) 彩字(蓝,字)
#define 绿字(字) 彩字(绿,字)
#define 重复(次数,语句) \
  for (int 数=1; 数 <= 次数; ++数) { \
    语句}
#define 遍历(成员数,语句) \
  for (int 下标=0; 下标 < 成员数; ++下标) { \
    语句}
#define 无限循环(代码) for(;;){代码}
#define 换行() 写<<endl;

常量 字节 棋盘顶=0,棋盘底=9,棋盘左=0,棋盘右=8,
黑方河界=4,红方河界=5,九宫左=3,九宫右=5;

#define 空 0

//兵种
#define 将 1//或帅
#define 车 2
#define 马 3
#define 炮 4
#define 士 5//或仕
#define 象 6//或相
#define 卒 7//或兵

//阵营
#define 黑方 1//显示为蓝色
#define 红方 2

#define 红加黑 3
#define 反转阵营(阵营) (红加黑-(阵营))

//红黑兵种
#define 黑将 1//或帅
#define 黑车 2
#define 黑马 3
#define 黑炮 4
#define 黑士 5//或仕
#define 黑象 6//或相
#define 黑卒 7//或兵

#define 红将 8//或帅
#define 红车 9
#define 红马 10
#define 红炮 11
#define 红士 12//或仕
#define 红象 13//或相
#define 红卒 14//或兵

#define 显名值(表达式) \
  写<<" "<<#表达式<<":"<<(表达式)<<" ";

#define 赢 10001.0
#define 输 -赢
#define 必杀 (赢-100)
struct 位置 {
    正字节 纵=0;//无符号避免小于0
    正字节  横=0;
};
struct 走法 {
    位置 起;
    位置 终;
}走法列表[100][111],杀手启发[100][2];
走法 对策;
字符串 走法文本(走法 走法);
#define 纵在棋盘(纵) (纵<10)
#define 横在棋盘(横) (横<9)
#define 位置在棋盘(位) (纵在棋盘(位.纵) and 横在棋盘(位.横))
#define 走法在棋盘(走法) (位置在棋盘(走法.起) and 位置在棋盘(走法.终))

#define 显示走法(走法) \
  写<<"起:纵"<<(int)走法.起.纵+1<<"横"<<(int)走法.起.横+1<<",终:纵" \
<<(int)走法.终.纵+1<<"横"<<(int)走法.终.横+1;

struct 棋子 {
    char 阵营=空;
    char 兵种=空;
}空棋子,局面[10][9],空局面[10][9];
#define 取棋子(位) 局面[位.纵][位.横]
无类型 间隙() {
    写 << 竖;
    重复(8,
           写 << "  "<<竖;)
    写 << endl;
}

字符串 棋子文本[3][8];//[阵营][兵种]

无类型 显示棋子(棋子 棋子)
{
    写<<棋子文本[棋子.阵营][棋子.兵种];
}

无类型 显示行(char 纵下标)
{
    显示棋子(局面[纵下标][0]);
    重复(8,
           写 << 横;
           显示棋子(局面[纵下标][数]);)
    写 << endl;
}

无类型 九宫间隙(string 斜杠1,string 斜杠2) {
    写 << 竖;
    重复(3,写 << "  "<<竖;)
    写 << 斜杠1+竖+斜杠2+竖;
    重复(3,写 << "  "<<竖;)
    写 << endl;
}
int 红减黑分数,棋子位置分数[3][8][10][9]= {},兵种分[8];

void 显示局面() {
    写 << "    中      国      象      棋" << endl;
    写 << "１  ２  ３  ４  ５  ６  ７  ８  ９" << endl;//全角数字
    显示行(0);
    九宫间隙("＼","／");
    显示行(1);
    九宫间隙("／","＼");
    显示行(2);
    间隙();
    显示行(3);
    间隙();
    显示行(4);
    写<<竖<<"  楚      河      汉      界  "<< 竖<<endl;
    显示行(5);
    间隙();
    显示行(6);
    间隙();
    显示行(7);
    九宫间隙("＼","／");
    显示行(8);
    九宫间隙("／","＼");
    显示行(9);
    写 << "九  八  七  六  五  四  三  二  一" << endl;
    写 <<"静态";
    显名值(红减黑分数)换行()
}
#define 审局(分数方) ((分数方) == 红方 ? 红减黑分数 : (- 红减黑分数))

#define 棋位分(棋子,位置) 棋子位置分数[棋子.阵营][棋子.兵种][位置.纵][位置.横]
字节 红黑兵种[3][8],一维坐标[10][9];
#define 棋值(棋子,数组) 数组[棋子.阵营][棋子.兵种]
#define 最低0(数) ((数)<0 ? 0 : (数))
整数 马位可能走法数(位置 起点) {
    整数 上,下,左,右;
    上=下=左=右=2;
    如果(起点.纵<棋盘顶+2) {
        上-=2;
    }
    如果(起点.纵>棋盘底-2) {
        下-=2;
    }
    如果(起点.横<棋盘左+2) {
        左-=2;
    }
    如果(起点.横>棋盘右-2) {
        右-=2;
    }
    如果(起点.纵==棋盘顶 or 起点.纵==棋盘底) {
        左=最低0(左-1);
        右=最低0(右-1);
    }
    如果(起点.横==棋盘左 or 起点.横==棋盘右) {
        上=最低0(上-1);
        下=最低0(下-1);
    }
    返回 上+下+左+右;
}

字符串 局面键 (91,(char)空);
字节 该走方,棋子数量;
void 开局赋值() {
    棋子数量=32;
    红减黑分数=0;
    该走方=红方;
    局面[0][4].兵种=局面[9][4].兵种=将;
    局面[0][0].兵种=
        局面[0][8].兵种=
            局面[9][0].兵种=
                局面[9][8].兵种=车;
    局面[0][1].兵种=
        局面[0][7].兵种=
            局面[9][1].兵种=
                局面[9][7].兵种=马;

    局面[2][1].兵种=
        局面[2][7].兵种=
            局面[7][1].兵种=
                局面[7][7].兵种=炮;
    局面[2][1].阵营=局面[2][7].阵营=黑方;
    局面[7][1].阵营=局面[7][7].阵营=红方;

    局面[0][2].兵种=
        局面[0][6].兵种=
            局面[9][2].兵种=
                局面[9][6].兵种=象;
    局面[0][3].兵种=
        局面[0][5].兵种=
            局面[9][3].兵种=
                局面[9][5].兵种=士;

    for(int 下标=0; 下标 < 9; ++下标)
    {
        局面[0][下标].阵营=黑方;
        局面[9][下标].阵营=红方;
        if(下标 % 2 == 0)
        {   局面[3][下标].兵种=卒;
            局面[3][下标].阵营=黑方;
            局面[6][下标].兵种=卒;
            局面[6][下标].阵营=红方;
        }
    }
    字节 下标=0;
    位置 位;

    for(位.纵=0; 位.纵<10; ++位.纵) {
        for(位.横=0; 位.横<9; ++位.横) {
            局面键[下标]=红黑兵种[取棋子(位).阵营][取棋子(位).兵种];
            红减黑分数+=棋位分(取棋子(位),位);
            ++下标;
        }
    }
    局面键[下标]=该走方;
    if(红减黑分数!=0) {
        写<<"初始化分数错误";
        cin.get();
    }
}
//if(!走法在棋盘(走法)){显名值(现在深度)显名值(走法数量)显示棋子(起点棋子);显示走法(走法)cin.get();}
#define 加入走法() \
  if(取棋子(走法.终).兵种==将) \
{走法列表[现在深度][0]=走法;返回 1;}\
else{走法列表[现在深度][走法数量]=走法; ++走法数量;}

#define 没吃友军走法() \
  if(取棋子(走法.终).阵营!=走棋方) { \
    加入走法()}

#define 车走法() \
  没吃友军走法() \
  if(取棋子(走法.终).阵营!=空){break;}

#define 炮走法() \
  if(取棋子(走法.终).阵营!=空) { \
    if(隔子==1){没吃友军走法() break;}\
    ++隔子;\
  }else{if(隔子==0){加入走法()}}

#define 马走法(长纵横,长加减,长限制,短纵横,短上限) \
  走法.终.长纵横 = 走法.起.长纵横 长加减 2; \
  if(走法.终.长纵横 长限制) { \
    阻.长纵横=走法.起.长纵横 长加减 1; \
    阻.短纵横=走法.起.短纵横; \
    if(取棋子(阻).阵营==空) { \
      走法.终.短纵横=走法.起.短纵横+1; \
      if(走法.终.短纵横 <= 短上限) { \
        没吃友军走法() \
      } \
      走法.终.短纵横=走法.起.短纵横-1; \
      if(走法.终.短纵横 <= 短上限) { \
        没吃友军走法() \
      } \
    } \
  }
char 获取走法(char 走棋方,无符号 char 现在深度) {
    //写<<"走棋方"<<走棋方+0;
    //写<<"现在深度"<<现在深度+0;
    //std::cin.get();
    char 走法数量 =0,隔子,九宫顶,九宫底,己方顶,己方底,前进;
    走法 走法;
    位置 阻;
    if(走棋方==红方) {
        九宫顶=7;
        九宫底=9;
        己方顶=5;
        己方底=9;
        前进=-1;
    }
    else {//黑方
        九宫顶=0;
        九宫底=2;
        己方顶=0;
        己方底=4;
        前进=1;
    }

    for(走法.起.纵=0; 走法.起.纵 < 10; ++走法.起.纵) {
        for(走法.起.横=0; 走法.起.横 < 9; ++走法.起.横) {
#define 起点棋子 取棋子(走法.起)

            if(起点棋子.阵营==走棋方) {
                //写<<"起点棋子.兵种"<<起点棋子.兵种+0;

                if(起点棋子.兵种==车) {
                    走法.终.纵=走法.起.纵;
                    for(走法.终.横=走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
                        车走法()
                    }
                    for(走法.终.横=走法.起.横-1; 走法.终.横 < 9; --走法.终.横) {
                        车走法()
                    }
                    走法.终.横=走法.起.横;
                    for(走法.终.纵=走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
                        车走法()
                    }
                    for(走法.终.纵=走法.起.纵-1; 走法.终.纵 <10; --走法.终.纵) {
                        车走法()
                    }
                } else if(起点棋子.兵种==炮) {
                    走法.终.纵=走法.起.纵;
                    隔子=0;
                    for(走法.终.横=走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
                        炮走法()
                    }
                    隔子=0;
                    for(走法.终.横=走法.起.横-1; 走法.终.横 <9; --走法.终.横) {
                        炮走法()
                    }
                    走法.终.横=走法.起.横;
                    隔子=0;
                    for(走法.终.纵=走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
                        炮走法()
                    }
                    隔子=0;
                    for(走法.终.纵=走法.起.纵-1; 走法.终.纵 <10; --走法.终.纵) {
                        炮走法()
                    }
                } else if(起点棋子.兵种==卒) {
                    //过河了
                    if(起点棋子.阵营==红方 ?
                            走法.起.纵 < 红方河界 :
                            走法.起.纵 > 黑方河界) {
                        走法.终.纵=走法.起.纵;

                        if(走法.起.横 <8) {
                            走法.终.横=走法.起.横+1;
                            没吃友军走法()
                        }

                        if(走法.起.横 >0) {
                            走法.终.横=走法.起.横-1;
                            没吃友军走法()
                        }
                    }
                    走法.终.横=走法.起.横;//不能后退
                    if(起点棋子.阵营==黑方 ) {
                        if(走法.起.纵<9) {
                            走法.终.纵=走法.起.纵+1;
                            没吃友军走法()
                        }
                    } else {
                        if(走法.起.纵>0)
                        {
                            走法.终.纵=走法.起.纵-1;
                            没吃友军走法()
                        }
                    }


                } else if(起点棋子.兵种==士) {
                    //不能出九宫
#define 士上(嵌套)\
          if(走法.起.纵>九宫顶)\
          {走法.终.纵=走法.起.纵-1;\
            嵌套}

#define 士下(嵌套)\
          if(走法.起.纵<九宫底)\
          {走法.终.纵=走法.起.纵+1;\
            嵌套}

                    if(走法.起.横 > 九宫左)
                    {   走法.终.横=走法.起.横-1;
                        士下(没吃友军走法())
                        士上(没吃友军走法())
                    }

                    if(走法.起.横 < 九宫右)
                    {   走法.终.横=走法.起.横+1;
                        士下(没吃友军走法())
                        士上(没吃友军走法())
                    }

                } else if(起点棋子.兵种==象) {
                    //不能过河
#define 象眼() \
          if(局面[阻.纵][阻.横].阵营==空)\
          {               没吃友军走法()}

#define 象上(嵌套)\
          if(走法.起.纵>己方顶)\
          {走法.终.纵=走法.起.纵-2;\
            阻.纵=走法.起.纵-1; 嵌套}

#define 象下(嵌套)\
          if(走法.起.纵<己方底)\
          {走法.终.纵=走法.起.纵+2;\
            阻.纵=走法.起.纵+1; 嵌套}

                    if(走法.起.横 > 棋盘左)
                    {   走法.终.横=走法.起.横-2;
                        阻.横=走法.起.横-1;
                        象下(象眼())
                        象上(象眼())
                    }

                    if(走法.起.横 < 棋盘右)
                    {   走法.终.横=走法.起.横+2;
                        阻.横=走法.起.横+1;
                        象下(象眼())
                        象上(象眼())
                    }



                } else if(起点棋子.兵种==马) {

                    马走法(纵,-,<10,横,8)马走法(纵,+,<=9,横,8)
                    马走法(横,-,<9,纵,9)马走法(横,+,<=8,纵,9)

                } else if(起点棋子.兵种==将) {
                    //不能出九宫
                    走法.终.纵=走法.起.纵;

                    if(走法.起.横 <5) {
                        走法.终.横=走法.起.横+1;
                        没吃友军走法()
                    }

                    if(走法.起.横 >3) {
                        走法.终.横=走法.起.横-1;
                        没吃友军走法()
                    }

                    走法.终.横=走法.起.横;

                    if(走法.起.纵 < 九宫底) {
                        走法.终.纵=走法.起.纵+1;
                        没吃友军走法()
                    }
                    if( 走法.起.纵>九宫顶) {
                        走法.终.纵=走法.起.纵-1;
                        没吃友军走法()
                    }
                    for(走法.终.纵=7-九宫顶; 走法.终.纵<=11-九宫底; ++走法.终.纵)
                    {
                        if(取棋子(走法.终).兵种==将)
                        {
                            阻.横=走法.起.横;
                            for(阻.纵=走法.起.纵+前进; 阻.纵!=走法.终.纵; 阻.纵+=前进)
                            {
                                if(取棋子(阻).阵营!=空) {
                                    goto 兵种结束;
                                }
                            }
                            走法列表[现在深度][0]=走法;
                            返回 1;
                        }
                    }
                }
兵种结束:
                ;
            }
        }
    }
    //cin.get();
退出:
    返回 走法数量 ;
}

#define 马物质权重 0.75
#define 马空间权重 (1-马物质权重)
#define 士象物质权重 (0.9*(0.7))
#define 士象空间权重 (1*0.7-士象物质权重)

void 初始化() {
    遍历(8,红黑兵种[空][下标]=空;)
    重复(2,红黑兵种[数][空]=空;)
    红黑兵种[黑方][将]=黑将;
    红黑兵种[黑方][车]=黑车;
    红黑兵种[黑方][马]=黑马;
    红黑兵种[黑方][炮]=黑炮;
    红黑兵种[黑方][士]=黑士;
    红黑兵种[黑方][象]=黑象;
    红黑兵种[黑方][卒]=黑卒;

    红黑兵种[红方][将]=红将;
    红黑兵种[红方][车]=红车;
    红黑兵种[红方][马]=红马;
    红黑兵种[红方][炮]=红炮;
    红黑兵种[红方][士]=红士;
    红黑兵种[红方][象]=红象;
    红黑兵种[红方][卒]=红卒;

    遍历(8,棋子文本[空][下标]="  ";)
    重复(2,棋子文本[数][空]="  ";)
    棋子文本[黑方][将]=蓝字("将");
    棋子文本[黑方][车]=蓝字("车");
    棋子文本[黑方][马]=蓝字("马");
    棋子文本[黑方][炮]=蓝字("炮");
    棋子文本[黑方][士]=蓝字("士");
    棋子文本[黑方][象]=蓝字("象");
    棋子文本[黑方][卒]=蓝字("卒");

    棋子文本[红方][将]=红字("帅");
    棋子文本[红方][车]=红字("车");
    棋子文本[红方][马]=红字("马");
    棋子文本[红方][炮]=红字("炮");
    棋子文本[红方][士]=红字("仕");
    棋子文本[红方][象]=红字("相");
    棋子文本[红方][卒]=红字("兵");

#define 控1位 50
    兵种分[空]=0;
    兵种分[将]=赢;
    兵种分[车]=(9+8)*控1位+90;
    兵种分[炮]=(9+8)*控1位/2+90;
    兵种分[马]=(8)*控1位+90;
    兵种分[士]=(4)*控1位+5;
    兵种分[象]=(4)*控1位+7;
    兵种分[卒]=(1)*控1位+9;

    棋子 子;
    位置 位,将原位,帅原位;
    将原位.纵=0;
    将原位.横=4;
    帅原位.纵=9;
    帅原位.横=4;
#define 取距离分(位1,位2) \
  ((9-绝对值(位1.纵-位2.纵))*10+(4-绝对值(位1.横-位2.横))*11)
#define 中线 4
    字节 下标=0,走法数量;
    //局面=空局面;
    for(位.纵=0; 位.纵<=9; ++位.纵) {
        for(位.横=0; 位.横<=8; ++位.横) {
            一维坐标[位.纵][位.横]=下标;
            ++下标;

            子.阵营=红方;
            子.兵种=将;
            棋位分(子,位)=赢+取距离分(位,帅原位);
            子.兵种=车;
            棋位分(子,位)=兵种分[车]+取距离分(位,将原位);
            子.兵种=炮;
            棋位分(子,位)=兵种分[炮]+取距离分(位,将原位);
            子.兵种=马;
            棋位分(子,位)=90+8*控1位*马物质权重+控1位*马位可能走法数(位)*马空间权重+取距离分(位,将原位);
            子.兵种=士;
            棋位分(子,位)=5+4*控1位*士象物质权重+控1位*(位.横==中线 ? 4 : 1)*士象空间权重+取距离分(位,帅原位);
            子.兵种=象;
            棋位分(子,位)=7+4*控1位*士象物质权重+控1位*(位.横==中线 ? 4 : 2)*士象空间权重+取距离分(位,帅原位);
            子.兵种=卒;
            取棋子(位)=子;
            走法数量=获取走法(子.阵营,0);
            棋位分(子,位)=走法数量*控1位+9+取距离分(位,将原位);

            子.阵营=黑方;
            子.兵种=将;
            棋位分(子,位)-=赢+取距离分(位,将原位);
            子.兵种=车;
            棋位分(子,位)-=兵种分[车]+取距离分(位,帅原位);
            子.兵种=炮;
            棋位分(子,位)-=兵种分[炮]+取距离分(位,帅原位);
            子.兵种=马;
            棋位分(子,位)-=90+8*控1位*马物质权重+控1位*马位可能走法数(位)*马空间权重+取距离分(位,帅原位);
            子.兵种=士;
            棋位分(子,位)-=5+4*控1位*士象物质权重+控1位*(位.横==中线 ? 4 : 1)*士象空间权重+取距离分(位,将原位);
            子.兵种=象;
            棋位分(子,位)-=7+4*控1位*士象物质权重+控1位*(位.横==中线 ? 4 : 2)*士象空间权重+取距离分(位,将原位);
            子.兵种=卒;
            取棋子(位)=子;
            走法数量=获取走法(子.阵营,0);
            棋位分(子,位)-=走法数量*控1位+9+取距离分(位,帅原位);

            取棋子(位)=空棋子;
        }
    }

    //中炮
    子.兵种=炮;
    位.横=中线;
    for(位.纵=0; 位.纵<=9; ++位.纵) {
        子.阵营=红方;
        棋位分(子,位)+=控1位;
        子.阵营=黑方;
        棋位分(子,位)-=控1位;
    }

    //窝心
    子.阵营=红方;
    子.兵种=马;
    位.纵=8;
    位.横=中线;
    棋位分(子,位)-=控1位;
    //*
    子.兵种=车;
    棋位分(子,位)-=控1位;
    //*
    子.兵种=炮;
    棋位分(子,位)-=控1位/2;
    //*/
    子.阵营=黑方;
    子.兵种=马;
    位.纵=1;
    棋位分(子,位)+=控1位;
    //*
    子.兵种=车;
    棋位分(子,位)+=控1位;
    //*
    子.兵种=炮;
    棋位分(子,位)+=控1位/2;
    //*/

    //*37兵卒
    子.兵种=卒;
    位.纵=3;
    位.横=2;
    棋位分(子,位)+=控1位;
    位.横=6;
    棋位分(子,位)+=控1位;

    子.阵营=红方;
    位.纵=6;
    棋位分(子,位)-=控1位;
    位.横=2;
    棋位分(子,位)-=控1位;//*/

    红减黑分数=0;
    for(位.纵=0; 位.纵<=9; ++位.纵) {
        for(位.横=0; 位.横<=8; ++位.横) {
            for(子.阵营=1; 子.阵营<=2; ++子.阵营) {
                for(子.兵种=1; 子.兵种<=7; ++子.兵种) {
                    红减黑分数+=棋位分(子,位);
                }
            }
        }
    }
    if(红减黑分数!=0) {
        写<<"初始化审局分数数组错误";
        cin.get();
    }
}
无符号 int 历史启发[10][9][10][9] = {},历史启发次数,杀手启发次数,置换启发次数,杀手分[2],纵历史分[10]= {},横历史分[9]= {};
#define 历史分(走法) 历史启发[走法.起.纵][走法.起.横][走法.终.纵][走法.终.横]

#define 交换(甲,乙,暂) \
  暂=甲;  \
  甲=乙;  \
  乙=暂;

void 走法排序(char 深度,char 数量)
{
    杀手分[0]=历史分(杀手启发[深度][0]);
    历史分(杀手启发[深度][0])=UINT_MAX;
    杀手分[1]=历史分(杀手启发[深度][1]);
    历史分(杀手启发[深度][1])=UINT_MAX-1;

    有符号 char 下标,顺区尾,乱区首;//插入排序
    走法 暂;
    auto 暂分=历史分(暂);
#define 前 走法列表[深度][下标]
#define 后 走法列表[深度][下标+1]
#define 纵横分(位置) (纵历史分[位置.纵]+横历史分[位置.横])
    //#define 走法静态分(走法) (-棋位分(取棋子(走法.起),走法.起)+棋位分(取棋子(走法.起),走法.终)-棋位分(取棋子(走法.终),走法.终))
#define 走法静态分(走法) (-棋位分(取棋子(走法.终),走法.终))
    //#define 排序条件() (历史分(前)+0.0+走法静态分(前) < 0.0+历史分(暂)+走法静态分(暂))
#define 排序条件() (历史分(前) < 暂分)
    //-纵横分(暂.起) +纵横分(暂.终)
    for(乱区首=1; 乱区首<数量; ++乱区首)
    {
        暂=走法列表[深度][乱区首];
        暂分=历史分(暂);
        下标=顺区尾=乱区首-1;
        if(排序条件())
        {
            后=前;
            for(--下标; 下标>=0; --下标) {
                if(排序条件())
                {
                    后=前;
                } else
                {
                    break;
                }
            }
            后=暂;
        }
    }
    历史分(杀手启发[深度][0])=杀手分[0];
    历史分(杀手启发[深度][1])=杀手分[1];
}

void 吃子走法排序(无符号 char 深度,char 数量)
{
    有符号 char 下标,乱区首,顺区尾;//插入排序
    走法 暂;
    auto 暂分=兵种分[空];
    for(乱区首=1; 乱区首<数量; ++乱区首)
    {   暂=走法列表[深度][乱区首];
        //auto 暂分=走法静态分(暂);
        暂分=兵种分[取棋子(暂.终).兵种];
        下标=顺区尾=乱区首-1;
        if(兵种分[取棋子(前.终).兵种] < 暂分)
            //if(走法静态分(前) < 暂分)
        {
            后=前;

            for(--下标; 下标>=0; --下标) {

                if(兵种分[取棋子(前.终).兵种] < 暂分)
                {
                    后=前;
                } else
                {
                    break;
                }

            }

            后=暂;
        }
    }
}
#undef 前
#undef 后
无符号 int 局面数量,预期深度;

bool 时间到;
int 静态搜索(int 阿尔法,int 贝塔,无符号 char 现在深度,char 走棋方)
{
    int 分数=审局(走棋方);
    if(分数>=贝塔 or 现在深度>99) {
        返回 分数;
    }
    char 走法数量 = 获取走法(走棋方,现在深度);
    if(走法数量==1) {
        返回 赢-现在深度;
    }
    分数+=走法数量;
    if(分数>=贝塔) {
        返回 分数;
    }
    char 对方=反转阵营(走棋方);
    int 最优值,备份;
    最优值 = 分数;
    //最优值 = 输;
    if(分数>阿尔法) {
        阿尔法=分数;
    }
    备份=红减黑分数;
    棋子 移动棋子,被吃棋子;
    走法 走法;
    吃子走法排序(现在深度,走法数量);
    for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
    {
        走法=走法列表[现在深度][走法下标];

        被吃棋子=局面[走法.终.纵][走法.终.横];
        if(被吃棋子.阵营==对方)
        {
            移动棋子=局面[走法.起.纵][走法.起.横];

            //走棋
            局面[走法.起.纵][走法.起.横]=空棋子;
            局面[走法.终.纵][走法.终.横]=移动棋子;
            红减黑分数 += -棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);

            ++局面数量;
            分数 = -静态搜索(-贝塔,-阿尔法,现在深度+1,对方);

            //悔棋
            局面[走法.起.纵][走法.起.横]=移动棋子;
            局面[走法.终.纵][走法.终.横]=被吃棋子;
            红减黑分数=备份;
        } else {
            //continue;
            break;
        }

        if(分数>=贝塔) {
            返回 分数;
        }
        if(分数>最优值) {
            最优值 = 分数;
            if(分数>阿尔法) {
                阿尔法=分数;
            }
        }
    }
    返回 最优值;
}

int 是否绝杀(正字节 现在深度,char 走棋方)
{
    if(现在深度>=2) {
        返回 0;
    }
    int 分数,最优值 = 输;
    棋子 移动棋子,被吃棋子;
    char 走法数量 = 获取走法(走棋方,现在深度),对方=反转阵营(走棋方);
    if(走法数量==1) {
        返回 赢-现在深度;
    }

    for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
    {
        走法 走法=走法列表[现在深度][走法下标];
        被吃棋子=局面[走法.终.纵][走法.终.横];
        移动棋子=局面[走法.起.纵][走法.起.横];

        //走棋
        局面[走法.起.纵][走法.起.横]=空棋子;
        局面[走法.终.纵][走法.终.横]=移动棋子;

        //递归
        分数 = -是否绝杀(现在深度+1,对方);

        //悔棋
        局面[走法.起.纵][走法.起.横]=移动棋子;
        局面[走法.终.纵][走法.终.横]=被吃棋子;

        if(分数>必杀) {
            返回 分数;
        }
        if(分数>最优值) {
            最优值 = 分数;
        }
    }
    返回 最优值;
}

struct 蒙特卡洛树节点 {
    无符号 int 模拟次数=0;
    float 获胜次数=0;
};
map<字符串,蒙特卡洛树节点> 蒙特卡洛树;
#define 选择 0
#define 探索 1
#define 扩展 2
#define  保存退出()\
  蒙特卡洛树[局面键]=暂存; \
返回 暂存;

蒙特卡洛树节点 蒙特卡洛树搜索(字节 现在深度,字节 模式) {
    ++局面数量;
    字节 走棋方=局面键[90],对方=反转阵营(走棋方);

    蒙特卡洛树节点 暂存;
    if(现在深度>99)
    {   暂存.模拟次数=1;
        //暂存.获胜次数=(静态搜索(输,赢,现在深度, 走棋方)+0.0) / 赢;
        暂存.获胜次数=审局(走棋方)/ 赢;
        /*
           显名值(暂存.获胜次数)
           等待回车()*/
        返回 暂存;
    }

    auto 查找结果=蒙特卡洛树.find(局面键);
    if(查找结果==蒙特卡洛树.end())
    {
        if(模式==选择) {
            暂存.模拟次数=1;
            //暂存.获胜次数=(静态搜索(输,赢,现在深度, 走棋方)+0.0) / 赢;
            暂存.获胜次数=审局(走棋方)/ 赢;

            //显名值(审局(走棋方)/赢);
            //显名值(暂存.获胜次数);
            //如果(!时间到)等待回车()
            //蒙特卡洛树[局面键]=暂存;
            //暂存.模拟次数=0;
            返回 暂存;
        }否则 {模式=扩展;}

    } else {
        暂存=(*查找结果).second ;
    }

    if(模式==选择) {
        返回 暂存;
    }

    float 分数,备份,最优值 = 输;
    无符号 long 全走法模拟次数=0;
    棋子 移动棋子,被吃棋子;
    走法 走法,最好走法;
    备份=红减黑分数;
    char 走法下标,最好下标,走法数量 = 获取走法(走棋方,现在深度);
    吃子走法排序(现在深度,走法数量);
    蒙特卡洛树节点 走法信息[走法数量];

    for(走法下标 =0; 走法下标<走法数量; ++走法下标)
    {
        走法=走法列表[现在深度][走法下标];

        被吃棋子=取棋子(走法.终);
        if(被吃棋子.兵种==将) {//等待回车()
            ++暂存.模拟次数;
            ++暂存.获胜次数;
            蒙特卡洛树[局面键]=暂存;
            暂存.获胜次数=(赢-现在深度) / 赢;
            返回 暂存;
        } else
        {
            移动棋子=取棋子(走法.起);

            //走棋
            取棋子(走法.起)=空棋子;
            取棋子(走法.终)=移动棋子;
            红减黑分数+=-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
            局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
            局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
            局面键[90]=对方;

            //递归
            走法信息[走法下标] = 蒙特卡洛树搜索(现在深度+1,选择);

            //悔棋
            取棋子(走法.起)=移动棋子;
            取棋子(走法.终)=被吃棋子;
            红减黑分数=备份;
            局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
            局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
            局面键[90]=走棋方;
            /*
               如果(走法信息[走法下标].模拟次数==0){
               ++暂存.模拟次数;
               走法信息[走法下标].获胜次数=-走法信息[走法下标].获胜次数;
               暂存.获胜次数+=走法信息[走法下标].获胜次数;
               蒙特卡洛树[局面键]=暂存;
               返回 走法信息[走法下标];
               }      */
            全走法模拟次数+=走法信息[走法下标].模拟次数;

        }


    }
    for( 走法下标=0; 走法下标<走法数量; ++走法下标)
    {   走法=走法列表[现在深度][走法下标];

        如果(模式==扩展) {
            分数=(-走法信息[走法下标].获胜次数/走法信息[走法下标].模拟次数);
        }否则 {
            //分数=(-走法信息[走法下标].获胜次数/走法信息[走法下标].模拟次数)+0.3*(1-(走法信息[走法下标].模拟次数/(全走法模拟次数+0.0)));
            分数=(-走法信息[走法下标].获胜次数/走法信息[走法下标].模拟次数)+最小(1,sqrt(1*log(全走法模拟次数)/(走法信息[走法下标].模拟次数+0.0)));
        }
        if(分数>最优值) {
            最优值 = 分数;
            最好走法=走法;
            最好下标=走法下标;
        }
    }
    //写<<现在深度+0<<"("<<走法文本(最好走法)<<") ";

    如果(模式==扩展) {
        走法信息[0].获胜次数=最优值;
    }否则 {
        走法=最好走法;
        被吃棋子=取棋子(走法.终);
        移动棋子=取棋子(走法.起);

        //走棋
        取棋子(走法.起)=空棋子;
        取棋子(走法.终)=移动棋子;
        红减黑分数+=-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
        局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
        局面键[90]=对方;

        //递归
        走法信息[0] = 蒙特卡洛树搜索(现在深度+1,探索);
        走法信息[0].获胜次数=-走法信息[0].获胜次数;
        //悔棋
        取棋子(走法.起)=移动棋子;
        取棋子(走法.终)=被吃棋子;
        红减黑分数=备份;
        局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
        局面键[90]=走棋方;
    }
    //显名值(现在深度+0)显名值(走法信息[0].获胜次数) 换行()
    ++暂存.模拟次数;
    暂存.获胜次数+=走法信息[0].获胜次数;
    蒙特卡洛树[局面键]=暂存;
    返回 走法信息[0];

}

#define 低于预期 0
#define 符合预期 1
#define 高于预期 2
#define 没搜完 3
#define 杀或被杀 4

struct 搜索信息 {
    字节 深度=0;
    int 分数;
    字节 类型,棋子数量;
    走法 最好走法;//,第二走法;
}搜索暂存;
unordered_map<字符串,字节> 历史局面;
unordered_map<字符串,搜索信息> 置换表;

int 保存次数,置换次数,pvs假突破次数;
bool 可空着,pvs;
clock_t 开始,限时;
double 用时;
struct 变例 {
    无符号 char 走法数量=0;
    走法 走法路线[68];
};
字节 根局面走法数量,最好下标;


#define 删除历史局面() 历史局面.erase(局面键);
#define 加入历史局面() 历史局面[局面键]=1;

int 阿尔法贝塔搜索(int 阿尔法,int 贝塔,正字节 现在深度,char 走棋方,字节 剩余深度)
{
    ++局面数量;

    if(剩余深度<=0) {
        //返回 审局(走棋方);
        返回 静态搜索(阿尔法,贝塔,现在深度,走棋方);
    }

    //循环局面
    auto 查找历史=历史局面.find(局面键);
    如果(查找历史!=历史局面.end()) {
        返回 0;
    }

    字节 对方=反转阵营(走棋方),多搜=0;

    搜索信息 暂存;//置换表避免重复搜索
    auto 查找结果=置换表.find(局面键);
    如果(查找结果!=置换表.end()) {
        暂存=(*查找结果).second ;
        如果(暂存.类型==杀或被杀) {
            ++置换次数;
            返回 暂存.分数-(暂存.分数>0 ? 现在深度 : -现在深度);
        }
        如果(暂存.深度>=剩余深度 and
               (暂存.类型==符合预期 or
                (暂存.类型==高于预期 and 暂存.分数>=贝塔) or
                (暂存.类型==低于预期 and 暂存.分数<=阿尔法))) {
            ++置换次数;
            返回 暂存.分数;
        }
        //杀手启发[现在深度][1]=暂存.第二走法;
        //如果(现在深度==0)杀手启发[现在深度][1]=杀手启发[现在深度][0];
        杀手启发[现在深度][0]=暂存.最好走法;
        //暂存.第二走法=暂存.最好走法;
        ++置换启发次数;
    }

    int 最优值=输,备份=红减黑分数,分数,突破;
    加入历史局面()
    字节 被将=0,吃子;
    //*空着裁剪
    if(假 and
        可空着 and 现在深度>0
        //and 剩余深度>1
    ) {
        可空着=假;
        局面键[90]=对方;
        //分数 = -阿尔法贝塔搜索(-贝塔,-贝塔+1,现在深度+1,对方,剩余深度/2);
        分数 = -阿尔法贝塔搜索(-贝塔,-贝塔+1,现在深度+1,对方,剩余深度-2);
        局面键[90]=走棋方;
        可空着=真;
        如果(//0 and
            分数 < -必杀) {//被将军
            被将=1;
            //显名值(0+现在深度)显名值(分数)等待回车()
        }
        if(分数>=贝塔) {
            可空着=假;
            分数=阿尔法贝塔搜索(贝塔-1,贝塔,现在深度,走棋方,1);
            //分数=阿尔法贝塔搜索(贝塔-1,贝塔,现在深度,走棋方,剩余深度/2);
            可空着=真;
            如果(分数>=贝塔) {
                删除历史局面()
                返回 分数;
            }
        }
    }//*/
    字节 走法数量;
    if(现在深度>0) {
        走法数量=获取走法(走棋方,现在深度);
        if(走法数量==1) {//吃将帅
            删除历史局面()
            返回 赢-现在深度;
        }
        走法排序(现在深度,走法数量);
    }否则 走法数量=根局面走法数量;
    //auto 加分=pow(2,剩余深度);
    auto 加分=剩余深度*剩余深度;
    //auto 加分=剩余深度;
    //auto 加分=1;
    棋子 移动棋子,被吃棋子;
    暂存.类型=低于预期;
    暂存.棋子数量=棋子数量;
    走法 走法;
    字节 走法下标;
    for(走法下标=0; 走法下标<走法数量; ++走法下标)
    {
        走法=走法列表[现在深度][走法下标];
        /*
           if(!走法在棋盘(走法)){
           显名值(现在深度)显名值(分数)显名值(最优值)
           显名值(阿尔法)显名值(贝塔)显名值(走法数量)
           显名值(走法下标)显示走法(走法)显名值(备份)
           cin.get();}
        //*/
        被吃棋子=局面[走法.终.纵][走法.终.横];
        如果(被吃棋子.阵营==走棋方) {
            写<<"自相残杀";
            等待回车()
        }否则 如果(被吃棋子.阵营==对方) {
            吃子=真;
            --棋子数量;
        }
        移动棋子=局面[走法.起.纵][走法.起.横];

        //走棋
        局面[走法.起.纵][走法.起.横]=空棋子;
        局面[走法.终.纵][走法.终.横]=移动棋子;
        局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
        局面键[90]=对方;
        红减黑分数+=-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);

        多搜=被将 ;//or (被吃棋子.兵种!=空) ;//and 暂存.类型==符合预期;//写<<(int)多搜;cin.get();

        if(pvs and
                暂存.类型==符合预期
                //走法下标>0
          ) {
            分数 = - 阿尔法贝塔搜索(-阿尔法-1,-阿尔法,现在深度+1,对方,剩余深度-1+多搜);
            if(阿尔法<分数 and 分数<贝塔) {
                突破=分数;
                分数 = - 阿尔法贝塔搜索(-贝塔,-阿尔法,现在深度+1,对方,剩余深度-1+多搜);
                if(分数<突破) {
                    ++pvs假突破次数;
                    //写<<"错误";显名值(阿尔法)显名值(突破)显名值(分数)
                    //cin.get();
                }
            }
        } else {
            分数 = - 阿尔法贝塔搜索(- 贝塔,- 阿尔法,现在深度+1,对方,剩余深度-1+多搜);
        }

        //悔棋
        局面[走法.起.纵][走法.起.横]=移动棋子;
        局面[走法.终.纵][走法.终.横]=被吃棋子;
        局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
        局面键[90]=走棋方;
        红减黑分数=备份;
        棋子数量=暂存.棋子数量;


        if(时间到) {
            if(走法下标==0) {
                删除历史局面()
                返回 暂存.分数;
            }
            暂存.类型=没搜完;
            break;
        }

        if(分数>最优值) {
            最优值 = 分数;
            暂存.最好走法= 走法;
            最好下标=走法下标;
            if(分数>=贝塔) {
                历史分(走法)+=加分;
                //纵历史分[暂存.最好走法.终.纵]+=剩余深度;
                //横历史分[暂存.最好走法.终.横]+=剩余深度;
                ++历史启发次数;
                //杀手启发[现在深度][1]=杀手启发[现在深度][0];
                杀手启发[现在深度][0]=走法;
                ++杀手启发次数;
                暂存.类型=高于预期;
                //break;
                goto 保存;
            }

            if(分数>阿尔法) {
                阿尔法=分数;
                暂存.类型=符合预期;
            }否则 如果(//分数<阿尔法 and
                历史分(走法)>=加分) {
                历史分(走法)-=加分;
            }
        }

    }
    如果(假 and 暂存.类型==符合预期) {
        ++历史分(暂存.最好走法);
        ++历史启发次数;
    }
    //历史分(暂存.最好走法)+=剩余深度;
    // ++纵历史分[暂存.最好走法.终.纵];
    // ++横历史分[暂存.最好走法.终.横];
保存:
    //显名值(剩余深度+0)显名值(暂存.深度+0)等待回车()
    if(剩余深度>=暂存.深度) {
        暂存.深度=剩余深度;
        如果(//假 and
            绝对值(最优值)>必杀 and (! 时间到)
            and 暂存.类型==符合预期
            ) {
            暂存.类型=杀或被杀;
            暂存.分数=最优值+(最优值>0 ? 现在深度 : -现在深度);
        }
        否则 
        {暂存.分数=最优值; }
        置换表[局面键]=暂存;
        ++保存次数;
    }
退出:
    删除历史局面()
    返回 最优值;
}
//#undef 走法

常量 字符串 零到九[]= {"零","一","二","三","四","五","六","七","八","九"};
字符串 红黑数字文本(字节 阵营,正字节 数字,bool 是横) {
    返回 (数字<=9 ?
            (阵营==黑方 ?
             to_string(数字) : 零到九[是横 ? 10-数字 : 数字]):"错误走法");
}
字符串 走法文本(走法 走法) {
    棋子 子=取棋子(走法.起);
    if((!走法在棋盘(走法)) or 子.阵营==空) {
        写<<"错误走法";
        读.get();
    }
    字符串 着法= {};
    字节 同子数=0;
    位置 位=走法.起;
    for(位.纵=0; 位.纵<10; 位.纵++) {
        如果(取棋子(位).阵营==子.阵营 and 取棋子(位).兵种==子.兵种) {
            如果(位.纵!=走法.起.纵) {
                着法+=((位.纵<走法.起.纵) == (子.阵营==红方) ? "后" : "前");
                同子数++;
                break;
            }
            否则 如果(同子数>0) {}
        }
    }
    着法+=棋值(子,棋子文本)+(同子数>0 ? "" : 红黑数字文本(子.阵营,走法.起.横+1,真));
    if(走法.起.纵==走法.终.纵) {
        着法+="平";
    } else if((走法.起.纵<走法.终.纵)==(子.阵营==黑方))
    {
        着法+="进";
    }
    else {
        着法+="退";
    }
    if(走法.起.横==走法.终.横) {
        着法+=红黑数字文本(子.阵营,绝对值(走法.起.纵-走法.终.纵),假);
    }
    else {
        着法+=红黑数字文本(子.阵营,走法.终.横+1,真);
    }
    返回 着法;
}
#define 宏走棋(走法) \
  棋子 被吃棋子=局面[走法.终.纵][走法.终.横],移动棋子=局面[走法.起.纵][走法.起.横]; \
  棋子数量-=(被吃棋子.阵营!=空);\
  局面[走法.起.纵][走法.起.横]=空棋子; \
  局面[走法.终.纵][走法.终.横]=移动棋子; \
  局面键[一维坐标[走法.起.纵][走法.起.横]]=空; \
  局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种); \
  局面键[90]=反转阵营(局面键[90]);

void 显示变例(字节 下标) {
    if(下标<预期深度) {
        auto 查找结果=置换表.find(局面键);
        if(查找结果!=置换表.end()) {
            搜索信息 暂存=(*查找结果).second ;
            走法 走法=暂存.最好走法;
            如果(下标==0) {
                对策=走法;
            }
            //如果(暂存.类型!=符合预期){返回;}

            写<<下标+1<<"(";
            //显示走法(走法)
            写<<走法文本(走法)<<") ";

            宏走棋(走法)

            显示变例(下标+1);//递归
            //悔棋
            局面[走法.起.纵][走法.起.横]=移动棋子;
            局面[走法.终.纵][走法.终.横]=被吃棋子;
            局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
            局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
            局面键[90]=反转阵营(局面键[90]);
        }
    }
}
float 蒙特卡洛树变例(字节 现在深度) {
    if(现在深度>99) {
        返回 0;
    }
    字节 走棋方=局面键[90],对方=反转阵营(走棋方);

    蒙特卡洛树节点 走法信息[110];

    float 分数,胜率,备份,最优值 = 输,最优胜率,最优次数;
    bool 没找到=假;
    棋子 移动棋子,被吃棋子;
    走法 走法,最好走法;
    char 走法数量 = 获取走法(走棋方,现在深度);
    for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
    {
        走法=走法列表[现在深度][走法下标];
        被吃棋子=取棋子(走法.终);
        移动棋子=取棋子(走法.起);

        //走棋
        局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
        局面键[90]=对方;


        auto 查找结果=蒙特卡洛树.find(局面键);
        if(查找结果!=蒙特卡洛树.end()) {
            走法信息[走法下标]=(*查找结果).second ;
            胜率=(-走法信息[走法下标].获胜次数/走法信息[走法下标].模拟次数);
            //分数=(走法信息[走法下标].模拟次数);
            分数=胜率  ;

            //显名值(走法信息[走法下标].获胜次数);
            //显名值(走法信息[走法下标].模拟次数);
            //显名值(分数);
        }否则 {没找到=真;
                }
        //悔棋
        局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
        局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
        局面键[90]=走棋方;

        如果(没找到)返回 最优胜率;

        if(分数>最优值) {
            最优值 = 分数;
            最优胜率=胜率;
            最好走法=走法;
            最优次数=走法信息[走法下标].模拟次数;
        }
    }
    if(现在深度==0) {
        对策=最好走法;
        显名值(最优值)
        显名值(最优次数)
    }
    写<<现在深度+1<<"("<<走法文本(最好走法)<<") ";
    走法=最好走法;
    被吃棋子=取棋子(走法.终);
    移动棋子=取棋子(走法.起);

    //走棋
    局面[走法.起.纵][走法.起.横]=空棋子;
    局面[走法.终.纵][走法.终.横]=移动棋子;
    局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
    局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
    局面键[90]=对方;

    蒙特卡洛树变例( 现在深度+1);//递归

    局面[走法.起.纵][走法.起.横]=移动棋子;
    局面[走法.终.纵][走法.终.横]=被吃棋子;
    局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
    局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
    局面键[90]=走棋方;

    返回 最优胜率;
}

bool 走法错误;
time_t 秒;
#define 显示时间() time(&秒);写<<ctime(&秒);

void 显示所有走法(字节 走棋方) {
    写<<"现在可走：0(退出游戏) ";
    int 现在深度=0,走法数量=获取走法(走棋方,现在深度);
    //走法排序(现在深度,走法数量);
    走法 走法;
    位置 起;
    for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
    {
        走法=走法列表[现在深度][走法下标];
        如果(走法.起.纵!=起.纵 or 走法.起.横!=起.横)换行()
        写<<走法下标+1<<"("<<走法文本(走法)<<") ";
        起=走法.起;
    }
    字符串 输入;

    int 走法序号;

    do {
        换行()
        写<<"你选择：";
        读>>输入;
        走法序号=stoi("0"+输入);
        如果(走法序号<1 or 走法序号>走法数量) {
            走法错误=真;
            如果(走法序号==0 and 输入=="0") {
                返回;
            }
            写<<"走法错误!";//<<走法数量;
            //返回;
        } else {
            走法错误=假;
            走法=走法列表[现在深度][走法序号-1];
            写<<走法文本(走法);
            换行()
            宏走棋(走法)
            红减黑分数+=-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
            该走方=反转阵营(该走方);
        }
    } while(走法错误);
}

int MTDF(int 猜测, int 深度) {
    int 分数, 贝塔, 顶, 底;
    分数 = 猜测;
    顶 = 赢;
    底 = 输;
    换行()写<<"MTDF搜索";
    //显名值(深度)
    do {
        贝塔 = (分数 == 底 ? 分数 + 1 : 分数);
        分数 = 阿尔法贝塔搜索( 贝塔 - 1, 贝塔,0,该走方,深度);
        显名值(分数)
        (分数 < 贝塔 ? 顶 : 底) = 分数;
    } while (底 < 顶 and !时间到);
    return 分数;
}

int 最大偏差=0;
int 期望搜索(int 猜测,int 深度) {
    int 顶,底,分数;
    int 第几次=1;
    换行()写<<"期望搜索";//显名值(猜测)
    顶=猜测+1;
    底=猜测-1;
    //顶=猜测+1+最大偏差;底=猜测-1-最大偏差;
    //显名值(深度)
    bool 最后一次=假;
    for(; 第几次<10 and !时间到; ++第几次) {
        分数=阿尔法贝塔搜索(底,顶,0,该走方,深度);
        //返回 分数;
        显名值(顶)显名值(底)

        显名值(分数)
        如果(最后一次) {
            返回 分数;
        }
        if(分数>=顶) {
            底=分数-1;
            顶=赢;
            最后一次=真;
            //顶=分数+1+最大偏差;
        }
        else if(分数<=底) {
            顶=分数+1;
            底=输;
            最后一次=真;
            //底=分数-1-最大偏差;
        }
        else {
            break;
        }
    }
    返回 分数;
}
auto 计时() {
    std::this_thread::sleep_for(std::chrono::milliseconds(限时*1000-10));
    时间到=真;
    返回 ;
}
#define 是否结束() \
  分数=是否绝杀(0,该走方);\
  如果(绝对值(分数)>必杀) \
{写<<((该走方==黑方) == (分数<0) ? "红" : "黑")<<"方胜!";换行()break;}
int main()
{
    ios::sync_with_stdio(假);
    初始化();
    开局赋值();
    bool 胜负未分=真;
    float 分数,猜测=0,偏差,模拟次数;
    字符串 文本=局面键;
    该走方=红方;
    蒙特卡洛树节点 根;
    do {
        显示局面();
        显示时间()
        是否结束()
        加入历史局面()

        开始 = clock();
        int 置换表大小=0;
        auto 键和值 = 置换表.begin();
        while(键和值 != 置换表.end()) {
            ++置换表大小;
            //cout << 键和值->second.棋子数量+0 << endl;
            if(键和值->second.棋子数量 > 棋子数量)
                置换表.erase(键和值++);
            else
                键和值++;
        }
        显名值(置换表大小)
        用时=(clock()-开始);
        用时=最大(1,用时);
        用时/=CLOCKS_PER_SEC;
        显名值(用时)

        显示所有走法(该走方);
        如果(走法错误) {
            写<<"程序退出...";
            换行()返回 4;
        }
        显示局面();
        显示时间()
        是否结束()

        /*
           写<<"\u4f60\u597d\U0001f60a\U0001f601";
           显名值(UINT_MAX)//显名值(1 and 1)
           显名值(文本.size())显名值(sizeof(文本))
           读.get();
        //*/
        开始 = clock();
        限时=10;//秒
        thread 计时线程(计时);
        计时线程.detach();
        pvs假突破次数=保存次数=置换次数=历史启发次数=杀手启发次数=置换启发次数=局面数量=0;
        时间到=假;
        可空着=真;
        //可空着=假;
        pvs=真;
        //pvs=假;
        模拟次数=0;
        根局面走法数量=获取走法(该走方,0);

        //迭代深化
        for(预期深度=1; 预期深度<100; ++预期深度) {
            //杀手启发[现在深度][1]=杀手启发[现在深度][0];
            //杀手启发[现在深度][0]=走法;
            走法排序(0,根局面走法数量);

            //分数=阿尔法贝塔搜索(输,赢,0,该走方,预期深度);
            分数=期望搜索(猜测,预期深度);
            //分数=MTDF(猜测,预期深度);

            /*
               auto 单次 = clock();
               do{
               蒙特卡洛树搜索(0,探索);
               ++模拟次数;
               }while((clock()-单次)<CLOCKS_PER_SEC and !时间到);
               换行()
               显名值(模拟次数)
               分数 = 蒙特卡洛树变例(0);//*/

            偏差=绝对值(分数-猜测);
            如果(预期深度>1 and 偏差>最大偏差) {
                最大偏差=偏差;
            }
            猜测=分数;
            用时=(clock()-开始);
            用时=最大(1,用时);
            用时/=CLOCKS_PER_SEC;
            换行()

            写<<" 搜索深度"<<预期深度<<(时间到 ? " 没搜完" : " 搜完了")<<" 分数"<< 分数
               <<" 局面数量"<<局面数量<<" 用时"
               <<用时<<"秒"<<" nps:"<<局面数量/用时/1000<<"k";
            显名值(置换表.size())显名值(置换次数) 显名值(杀手启发次数)显名值(置换启发次数)显名值(历史启发次数)
            显名值(保存次数)
            显名值(pvs假突破次数)显名值(最大偏差)显名值(可空着)显名值(pvs)
            写<<"\n 主变例:";
            显示变例(0);
            显名值(最好下标+0)
            换行()
            if(时间到
                    or 绝对值(分数)>必杀
              )break;
        }
        加入历史局面()
        宏走棋(对策)
        走法 走法=对策;
        红减黑分数+=-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);

        /*
           for(字节 走法下标=最好下标; 走法下标>0; --走法下标){
           走法列表[0][走法下标]=走法列表[0][走法下标-1];
           }
           走法列表[0][0]=对策;*/

        该走方=反转阵营(该走方);
        换行()
    } while(胜负未分);
    //显示时间()
#ifdef _WIN32
    写<<"可回车退出...";
    读.get();
#endif
    //pause();//system("PAUSE");
    返回 0;
}
