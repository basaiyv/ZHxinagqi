#include <iostream>
#include <string>
#include <ctime>
#include <unistd.h>
#include <cmath>
#include <climits>
#include <map>

#define 使用 using
#define 命名空间 namespace
使用 命名空间 std;
#define 整数 int
#define 主函数 main
#define 读 cin
#define 写 cout
#define 返回 return
#define 如果 if
#define 真 true
#define 假 false
#define 无类型 void
#define 常量 const
#define 有符号 signed
#define 无符号 unsigned
//typedef char 字节;
#define 字节 char
#define 正字节 无符号 字节
//typedef string 字符串;
#define 字符串 string

#define 模板 template
#define 类 class
模板 <类 数字>
数字 绝对值(数字 数) {
  返回 数<0 ? -数 : 数;
}
//数字 胜率=0.5;
#ifdef _WIN32
#include <windows.h>
#endif
常量 字符串 横="一";
常量 字符串 竖="丨";
常量 字符串 红="\e[31m";
#define 黄 "\e[33m"
#define 蓝 "\e[34m"
#define 绿 "\e[32m"
string 彩字(string 颜色码,string 字符)
{
  返回 颜色码+字符+"\e[0m" ;
}
#define 红字(字) 彩字(红,字)
#define 黄字(字) 彩字(黄,字)
#define 蓝字(字) 彩字(蓝,字)
#define 绿字(字) 彩字(绿,字)
#define 重复(次数,语句) \
  for (int 数=1; 数 <= 次数; ++数) { \
    语句}
#define 遍历(成员数,语句) \
  for (int 下标=0; 下标 < 成员数; ++下标) { \
    语句}
#define 无限循环(代码) for(;;){代码}
#define 换行() 写<<endl;

常量 字节 棋盘顶=0,棋盘底=9,棋盘左=0,棋盘右=8,
黑方河界=4,红方河界=5;

#define 空 0

//兵种
#define 将 1//或帅
#define 车 2
#define 马 3
#define 炮 4
#define 士 5//或仕
#define 象 6//或相
#define 卒 7//或兵

//阵营
#define 黑方 1//显示为蓝色
#define 红方 2

#define 红加黑 3
#define 反转阵营(阵营) (红加黑-(阵营))

//红黑兵种
#define 黑将 1//或帅
#define 黑车 2
#define 黑马 3
#define 黑炮 4
#define 黑士 5//或仕
#define 黑象 6//或相
#define 黑卒 7//或兵

#define 红将 8//或帅
#define 红车 9
#define 红马 10
#define 红炮 11
#define 红士 12//或仕
#define 红象 13//或相
#define 红卒 14//或兵

#define 显名值(表达式) \
  写<<" "<<#表达式<<":"<<(表达式)<<" ";

#define 赢 10000
#define 输 -赢
#define 必杀 (赢-100)
struct 位置 {
  //无符号 
  正字节 纵=0;//无符号避免小于0
  无符号 字节 横=0;
};
struct 走法 {
  位置 起;
  位置 终;
}走法列表[100][111],杀手启发[100][2];
#define 纵在棋盘(纵) (纵<10)
#define 横在棋盘(横) (横<9)
#define 位置在棋盘(位) (纵在棋盘(位.纵) and 横在棋盘(位.横))
#define 走法在棋盘(走法) (位置在棋盘(走法.起) and 位置在棋盘(走法.终))

#define 显示走法(走法) \
  写<<"起:纵"<<(int)走法.起.纵+1<<"横"<<(int)走法.起.横+1<<",终:纵" \
  <<(int)走法.终.纵+1<<"横"<<(int)走法.终.横+1;

struct 棋子 {
  char 阵营=空;
  char 兵种=空;
}空棋子,局面[10][9],空局面[10][9];
#define 取棋子(位) 局面[位.纵][位.横]
无类型 间隙() {
  写 << 竖;
  重复(8,
      写 << "  "<<竖;)
    写 << endl;
}

字符串 棋子文本[3][8];//[阵营][兵种]

无类型 显示棋子(棋子 棋子)
{
  写<<棋子文本[棋子.阵营][棋子.兵种];
}

无类型 显示行(char 纵下标)
{
  显示棋子(局面[纵下标][0]);
  重复(8,
      写 << 横;
      显示棋子(局面[纵下标][数]);)
  写 << endl;
}

无类型 九宫间隙(string 斜杠1,string 斜杠2) {
  写 << 竖;
  重复(3,写 << "  "<<竖;)
    写 << 斜杠1+竖+斜杠2+竖;
  重复(3,写 << "  "<<竖;)
    写 << endl;
}
void 显示局面() {
  写 << "    中      国      象      棋" << endl;
  写 << "１  ２  ３  ４  ５  ６  ７  ８  ９" << endl;//全角数字
  显示行(0);
  九宫间隙("＼","／");
  显示行(1);
  九宫间隙("／","＼");
  显示行(2);
  间隙();
  显示行(3);
  间隙();
  显示行(4);
  写<<竖<<"  楚      河      汉      界  "<< 竖<<endl;
  显示行(5);
  间隙();
  显示行(6);
  间隙();
  显示行(7);
  九宫间隙("＼","／");
  显示行(8);
  九宫间隙("／","＼");
  显示行(9);
  写 << "九  八  七  六  五  四  三  二  一" << endl;
}
int 红减黑分数,棋子位置分数[3][8][10][9]= {}
,兵种分[8];
int 审局(char 分数方) {
  if(分数方 == 红方) {
    返回(红减黑分数);
  } else {
    返回(- 红减黑分数);
  }
}
#define 棋位分(棋子,位置) 棋子位置分数[棋子.阵营][棋子.兵种][位置.纵][位置.横]
字节 红黑兵种[3][8],一维坐标[10][9];
#define 棋值(棋子,数组) 数组[棋子.阵营][棋子.兵种]
void 初始化() {
  遍历(8,
      红黑兵种[空][下标]=空;)
    重复(2,
        红黑兵种[数][空]=空;)
    红黑兵种[黑方][将]=黑将;
  红黑兵种[黑方][车]=黑车;
  红黑兵种[黑方][马]=黑马;
  红黑兵种[黑方][炮]=黑炮;
  红黑兵种[黑方][士]=黑士;
  红黑兵种[黑方][象]=黑象;
  红黑兵种[黑方][卒]=黑卒;

  红黑兵种[红方][将]=红将;
  红黑兵种[红方][车]=红车;
  红黑兵种[红方][马]=红马;
  红黑兵种[红方][炮]=红炮;
  红黑兵种[红方][士]=红士;
  红黑兵种[红方][象]=红象;
  红黑兵种[红方][卒]=红卒;

  遍历(8,
      棋子文本[空][下标]="  ";)
    重复(2,
        棋子文本[数][空]="  ";)
    棋子文本[黑方][将]=蓝字("将");
  棋子文本[黑方][车]=蓝字("车");
  棋子文本[黑方][马]=蓝字("马");
  棋子文本[黑方][炮]=蓝字("炮");
  棋子文本[黑方][士]=蓝字("士");
  棋子文本[黑方][象]=蓝字("象");
  棋子文本[黑方][卒]=蓝字("卒");

  棋子文本[红方][将]=红字("帅");
  棋子文本[红方][车]=红字("车");
  棋子文本[红方][马]=红字("马");
  棋子文本[红方][炮]=红字("炮");
  棋子文本[红方][士]=红字("仕");
  棋子文本[红方][象]=红字("相");
  棋子文本[红方][卒]=红字("兵");

  兵种分[空]=空;
  兵种分[将]=赢;
  兵种分[车]=(9+8)*50;
  兵种分[炮]=(9+8)*25;
  兵种分[马]=(8)*50;
  兵种分[士]=(4)*50;
  兵种分[象]=(4)*50;
  兵种分[卒]=(1)*50;

  棋子 子;
  位置 位,将原位,帅原位;
  将原位.纵=0;
  将原位.横=4;
  帅原位.纵=9;
  帅原位.横=4;
#define 取距离分(位1,位2) \
  ((9-绝对值(位1.纵-位2.纵))*1+(4-绝对值(位1.横-位2.横))*6)

  字节 下标=0;
  for(位.纵=0; 位.纵<=9; ++位.纵) {
    for(位.横=0; 位.横<=8; ++位.横) {
      一维坐标[位.纵][位.横]=下标;
      ++下标;

      子.阵营=红方;
      子.兵种=将;
      棋位分(子,位)=赢+取距离分(位,帅原位);
      子.兵种=车;
      棋位分(子,位)=(9+8)*50+取距离分(位,将原位);
      子.兵种=炮;
      棋位分(子,位)=(9+8)*25+取距离分(位,将原位);
      子.兵种=马;
      棋位分(子,位)=(8)*50+取距离分(位,将原位);
      子.兵种=士;
      棋位分(子,位)=(4)*50+取距离分(位,帅原位);
      子.兵种=象;
      棋位分(子,位)=(4)*50+取距离分(位,帅原位);
      子.兵种=卒;
      棋位分(子,位)=(位.纵<红方河界 ? 2 : 1)*50+取距离分(位,将原位);

      子.阵营=黑方;
      子.兵种=将;
      棋位分(子,位)-=赢+取距离分(位,将原位);
      子.兵种=车;
      棋位分(子,位)-=(9+8)*50+取距离分(位,帅原位);
      子.兵种=炮;
      棋位分(子,位)-=(9+8)*25+取距离分(位,帅原位);
      子.兵种=马;
      棋位分(子,位)-=(8)*50+取距离分(位,帅原位);
      子.兵种=士;
      棋位分(子,位)-=(4)*50+取距离分(位,将原位);
      子.兵种=象;
      棋位分(子,位)-=(4)*50+取距离分(位,将原位);
      子.兵种=卒;
      棋位分(子,位)-=(位.纵>黑方河界 ? 2 : 1)*50+取距离分(位,帅原位);
    }
  }
  //窝心
  子.阵营=红方;
  子.兵种=马;
  位.纵=8;
  位.横=4;
  棋位分(子,位)-=50;
  //*
  子.兵种=车;
  棋位分(子,位)-=50;
  //*
  子.兵种=炮;
  棋位分(子,位)-=25;
  //*/
  子.阵营=黑方;
  子.兵种=马;
  位.纵=1;
  棋位分(子,位)+=50;
  //*
  子.兵种=车;
  棋位分(子,位)+=50;
  //*
  子.兵种=炮;
  棋位分(子,位)+=25;
  //*/
  /*37兵卒 
  子.兵种=卒;
  位.纵=3;
  位.横=2;
  棋位分(子,位)+=5;
  位.横=6;
  棋位分(子,位)+=5;
  
  子.阵营=红方;
  位.纵=6;
  棋位分(子,位)-=5;
  位.横=2;
  棋位分(子,位)-=5;*/
  
  红减黑分数=0;
  for(位.纵=0; 位.纵<=9; ++位.纵) {
    for(位.横=0; 位.横<=8; ++位.横) {
      for(子.阵营=1; 子.阵营<=2; ++子.阵营) {
        for(子.兵种=1; 子.兵种<=7; ++子.兵种) {
          红减黑分数+=棋位分(子,位);
        }
      }
    }
  }
  if(红减黑分数!=0) {
    写<<"初始化审局分数数组错误";
    cin.get();
  }
}

字符串 局面键 (91,(char)空);
字节 该走方;
void 开局赋值() {
  红减黑分数=0;
  该走方=红方;
  局面[0][4].兵种=局面[9][4].兵种=将;
  局面[0][0].兵种=
    局面[0][8].兵种=
    局面[9][0].兵种=
    局面[9][8].兵种=车;
  局面[0][1].兵种=
    局面[0][7].兵种=
    局面[9][1].兵种=
    局面[9][7].兵种=马;

  局面[2][1].兵种=
    局面[2][7].兵种=
    局面[7][1].兵种=
    局面[7][7].兵种=炮;
  局面[2][1].阵营=局面[2][7].阵营=黑方;
  局面[7][1].阵营=局面[7][7].阵营=红方;

  局面[0][2].兵种=
    局面[0][6].兵种=
    局面[9][2].兵种=
    局面[9][6].兵种=象;
  局面[0][3].兵种=
    局面[0][5].兵种=
    局面[9][3].兵种=
    局面[9][5].兵种=士;

  for(int 下标=0; 下标 < 9; ++下标)
  {
    局面[0][下标].阵营=黑方;
    局面[9][下标].阵营=红方;
    if(下标 % 2 == 0)
    {   局面[3][下标].兵种=卒;
      局面[3][下标].阵营=黑方;
      局面[6][下标].兵种=卒;
      局面[6][下标].阵营=红方;
    }
  }
  字节 下标=0;
  位置 位;

  for(位.纵=0; 位.纵<10; ++位.纵) {
    for(位.横=0; 位.横<9; ++位.横) {
      局面键[下标]=红黑兵种[取棋子(位).阵营][取棋子(位).兵种];
      红减黑分数+=棋位分(取棋子(位),位);
      ++下标;
    }
  }
  局面键[下标]=该走方;
  if(红减黑分数!=0) {
    写<<"初始化分数错误";
    cin.get();
  }
}
//if(!走法在棋盘(走法)){显名值(目前深度)显名值(走法数量)显示棋子(起点棋子);显示走法(走法)cin.get();}
#define 加入走法() \
  if(取棋子(走法.终).兵种==将) \
{走法列表[目前深度][0]=走法;返回 1;}\
else{走法列表[目前深度][走法数量]=走法; ++走法数量;}

#define 没吃友军走法() \
  if(取棋子(走法.终).阵营!=走棋方) { \
    加入走法()}

#define 车走法() \
  没吃友军走法() \
  if(取棋子(走法.终).阵营!=空){break;}

#define 炮走法() \
  if(取棋子(走法.终).阵营!=空) { \
    if(隔子==1){没吃友军走法() break;}\
    ++隔子;\
  }else{if(隔子==0){加入走法()}}

#define 马走法(长纵横,长加减,长限制,短纵横,短上限) \
  走法.终.长纵横 = 走法.起.长纵横 长加减 2; \
  if(走法.终.长纵横 长限制) { \
    阻.长纵横=走法.起.长纵横 长加减 1; \
    阻.短纵横=走法.起.短纵横; \
    if(取棋子(阻).阵营==空) { \
      走法.终.短纵横=走法.起.短纵横+1; \
      if(走法.终.短纵横 <= 短上限) { \
        没吃友军走法() \
      } \
      走法.终.短纵横=走法.起.短纵横-1; \
      if(走法.终.短纵横 <= 短上限) { \
        没吃友军走法() \
      } \
    } \
  }
char 获取走法(char 走棋方,无符号 char 目前深度) {
  char 走法数量 =0,隔子,九宫顶,九宫底,己方顶,己方底,前进;
  走法 走法;
  位置 阻;
  if(走棋方==红方) {
    九宫顶=7;
    九宫底=9;
    己方顶=5;
    己方底=9;
    前进=-1;
  }
  else {//黑方
    九宫顶=0;
    九宫底=2;
    己方顶=0;
    己方底=4;
    前进=1;
  }

  for(走法.起.纵=0; 走法.起.纵 < 10; ++走法.起.纵) {
    for(走法.起.横=0; 走法.起.横 < 9; ++走法.起.横) {
#define 起点棋子 取棋子(走法.起)
      if(起点棋子.阵营==走棋方) {

        if(起点棋子.兵种==车) {
          走法.终.纵=走法.起.纵;
          for(走法.终.横=走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
            车走法()
          }
          for(走法.终.横=走法.起.横-1; 走法.终.横 < 9; --走法.终.横) {
            车走法()
          }
          走法.终.横=走法.起.横;
          for(走法.终.纵=走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
            车走法()
          }
          for(走法.终.纵=走法.起.纵-1; 走法.终.纵 <10; --走法.终.纵) {
            车走法()
          }
        } else if(起点棋子.兵种==炮) {
          走法.终.纵=走法.起.纵;
          隔子=0;
          for(走法.终.横=走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
            炮走法()
          }
          隔子=0;
          for(走法.终.横=走法.起.横-1; 走法.终.横 <9; --走法.终.横) {
            炮走法()
          }
          走法.终.横=走法.起.横;
          隔子=0;
          for(走法.终.纵=走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
            炮走法()
          }
          隔子=0;
          for(走法.终.纵=走法.起.纵-1; 走法.终.纵 <10; --走法.终.纵) {
            炮走法()
          }
        } else if(起点棋子.兵种==卒) {
          //过河了
          if(起点棋子.阵营==红方 ?
              走法.起.纵 < 红方河界 :
              走法.起.纵 > 黑方河界) {
            走法.终.纵=走法.起.纵;

            if(走法.起.横 <8) {
              走法.终.横=走法.起.横+1;
              没吃友军走法()
            }

            if(走法.起.横 >0) {
              走法.终.横=走法.起.横-1;
              没吃友军走法()
            }
          }
          走法.终.横=走法.起.横;//不能后退
          if(起点棋子.阵营==黑方 ) {
            if(走法.起.纵<9) {
              走法.终.纵=走法.起.纵+1;
              没吃友军走法()
            }
          } else {
            if(走法.起.纵>0)
            {
              走法.终.纵=走法.起.纵-1;
              没吃友军走法()
            }
          }


        } else if(起点棋子.兵种==士) {
          //不能出九宫
          for(走法.终.纵=走法.起.纵-1; 走法.终.纵 <= 九宫底; 走法.终.纵+=2) {
            for(走法.终.横=走法.起.横-1; 走法.终.横 <=5; 走法.终.横+=2) {

              if(走法.终.纵 >= 九宫顶
                  and 走法.终.横 >= 3) {
                没吃友军走法()
              }
            }
          }
        } else if(起点棋子.兵种==象) {
          //不能过河
          for(走法.终.纵=走法.起.纵-2,阻.纵=走法.起.纵-1; 走法.终.纵 >= 己方顶
              and 走法.终.纵 <= 己方底; 走法.终.纵+=4,阻.纵+=2) {
            for(走法.终.横=走法.起.横-2,阻.横=走法.起.横-1; 走法.终.横<=走法.起.横+2
                and 走法.终.横<=8  ; 阻.纵+=2,走法.终.横+=4) {

              if(局面[阻.纵][阻.横].阵营==空) {//象眼
                没吃友军走法()
              }
            }
          }
        } else if(起点棋子.兵种==马) {

          马走法(纵,-,<10,横,8)马走法(纵,+,<=9,横,8)
            马走法(横,-,<9,纵,9)马走法(横,+,<=8,纵,9)

        } else if(起点棋子.兵种==将) {
          //不能出九宫
          走法.终.纵=走法.起.纵;

          if(走法.起.横 <5) {
            走法.终.横=走法.起.横+1;
            没吃友军走法()
          }

          if(走法.起.横 >3) {
            走法.终.横=走法.起.横-1;
            没吃友军走法()
          }

          走法.终.横=走法.起.横;

          if(走法.起.纵 < 九宫底) {
            走法.终.纵=走法.起.纵+1;
            没吃友军走法()
          }
          if( 走法.起.纵>九宫顶) {
            走法.终.纵=走法.起.纵-1;
            没吃友军走法()
          }
          for(走法.终.纵=7-九宫顶;走法.终.纵<=11-九宫底;++走法.终.纵)
          {
            if(取棋子(走法.终).兵种==将)
            {
              阻.横=走法.起.横;
              for(阻.纵=走法.起.纵+前进;阻.纵!=走法.终.纵;阻.纵+=前进)
              {
                if(取棋子(阻).阵营!=空){
                  goto 兵种结束;}
              }
              走法列表[目前深度][0]=走法;返回 1;
            }
          }
        }
        兵种结束:;
      }
    }
  }
  退出:
    返回 走法数量 ;
}

无符号 int 历史启发[10][9][10][9] = {},历史启发次数,杀手启发次数,置换启发次数,杀手分[2];
#define 历史分(走法) 历史启发[走法.起.纵][走法.起.横][走法.终.纵][走法.终.横]

#define 交换(甲,乙,暂) \
  暂=甲;  \
甲=乙;  \
乙=暂;

void 走法排序(char 深度,char 数量)
{   杀手分[0]=历史分(杀手启发[深度][0]);
  历史分(杀手启发[深度][0])=UINT_MAX;
  杀手分[1]=历史分(杀手启发[深度][1]);
  历史分(杀手启发[深度][1])=UINT_MAX-1;

  有符号 char 下标,顺区尾,乱区首;//插入排序
  走法 暂;
#define 前 走法列表[深度][下标]
#define 后 走法列表[深度][下标+1]
  for(乱区首=1; 乱区首<数量; ++乱区首)
  {
    暂=走法列表[深度][乱区首];
    下标=顺区尾=乱区首-1;

    if(历史分(前) < 历史分(暂))
    {
      后=前;
      for(--下标; 下标>=0; --下标) {
        if(历史分(前) < 历史分(暂))
        {
          后=前;
        } else
        {
          break;
        }
      }
      后=暂;
    }
  }
  历史分(杀手启发[深度][0])=杀手分[0];
  历史分(杀手启发[深度][1])=杀手分[1];
}

void 吃子走法排序(无符号 char 深度,char 数量)
{
  有符号 char 下标,乱区首,顺区尾;//插入排序
  走法 暂;
  for(乱区首=1; 乱区首<数量; ++乱区首)
  {   暂=走法列表[深度][乱区首];
    下标=顺区尾=乱区首-1;
    if(兵种分[取棋子(前.终).兵种] < 兵种分[取棋子(暂.终).兵种])
    {
      后=前;

      for(--下标; 下标>=0; --下标) {

        if(兵种分[取棋子(前.终).兵种] < 兵种分[取棋子(暂.终).兵种])
        {
          后=前;
        } else
        {
          break;
        }

      }

      后=暂;
    }
  }
}
#undef 前
#undef 后
无符号 int 局面数量,预期深度;

bool 时间到;
int 静态搜索(int 阿尔法,int 贝塔,无符号 char 目前深度,char 走棋方)
{
  int 分数=审局(走棋方);
  if(分数>=贝塔) {
    返回 分数;
  }
  int 最优值,备份;
  //if(分数>输) {
  最优值 = 分数;
  if(分数>阿尔法) {
    阿尔法=分数;
  }
  棋子 移动棋子,被吃棋子;
  char 走法数量 = 获取走法(走棋方,目前深度);
  吃子走法排序(目前深度,走法数量);
  for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
  {
    走法 &走法=走法列表[目前深度][走法下标];

    被吃棋子=局面[走法.终.纵][走法.终.横];
    if(被吃棋子.兵种==将) {
      返回 赢-目前深度;
    } else if(被吃棋子.兵种!=空)
    {
      移动棋子=局面[走法.起.纵][走法.起.横];

      //走棋
      局面[走法.起.纵][走法.起.横]=空棋子;
      局面[走法.终.纵][走法.终.横]=移动棋子;
      备份=红减黑分数;
      红减黑分数=红减黑分数-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);

      ++局面数量;
      if(阿尔法==分数) {
        分数 = - 静态搜索(-阿尔法-1,-阿尔法,目前深度+1,反转阵营(走棋方));
        if(阿尔法<分数 and 分数<贝塔)
        {   goto 正常搜索;
        }
      }
      else {
        正常搜索:
          分数 = -静态搜索(-贝塔,-阿尔法,目前深度+1,反转阵营(走棋方));
      }


      //悔棋
      局面[走法.起.纵][走法.起.横]=移动棋子;
      局面[走法.终.纵][走法.终.横]=被吃棋子;
      红减黑分数=备份;
    } else {
      break;
    }

    if(分数>=贝塔) {
      返回 分数;
    }
    if(分数>最优值) {
      最优值 = 分数;
      if(分数>阿尔法) {
        阿尔法=分数;
      }
    }
  }
  返回 最优值;
}

int 是否绝杀(int 阿尔法,int 贝塔,正字节 目前深度,char 走棋方)
{
  if(目前深度>=2) {
    返回 审局(走棋方); }
  int 分数,备份,最优值 = 输;
  
  棋子 移动棋子,被吃棋子;
  char 走法数量 = 获取走法(走棋方,目前深度);
  for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
  {
    走法 &走法=走法列表[目前深度][走法下标];

    被吃棋子=局面[走法.终.纵][走法.终.横];
    if(被吃棋子.兵种==将) {
      返回 赢-目前深度;
    } else 
    {
      移动棋子=局面[走法.起.纵][走法.起.横];

      //走棋
      局面[走法.起.纵][走法.起.横]=空棋子;
      局面[走法.终.纵][走法.终.横]=移动棋子;
      备份=红减黑分数;
      红减黑分数=红减黑分数-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
      
      //递归
      分数 = -是否绝杀(-贝塔,-阿尔法,目前深度+1,反转阵营(走棋方));

      //悔棋
      局面[走法.起.纵][走法.起.横]=移动棋子;
      局面[走法.终.纵][走法.终.横]=被吃棋子;
      红减黑分数=备份;
    } 
    if(分数>=贝塔) {
      返回 分数;
    }
    if(分数>最优值) {
      最优值 = 分数;
      if(分数>阿尔法) {
        阿尔法=分数;
      }
    }
  }
  返回 最优值;
}

struct 蒙特卡洛树节点 {
  无符号 int 模拟次数=0;
  int 获胜次数=0;
};

#include <unordered_map>
//#include <hash_map>
struct 搜索信息 {
  无符号 char 深度;
  int 分数;
  字节 类型;
  走法 最好走法;
}搜索暂存;
unordered_map<string,搜索信息> 置换表;
int 保存次数,置换次数;
#define 低于预期 0
#define 符合预期 1
#define 高于预期 2
#define 没搜完 3
bool 非空着,pvs;
clock_t 开始,限时;
double 用时;
struct 变例 {
  无符号 char 走法数量=0;
  走法 走法路线[68];
};
无符号 字节 吃子数;
int 阿尔法贝塔搜索(int 阿尔法,int 贝塔,无符号 char 目前深度,char 走棋方,无符号 字节 目标深度)
{
  ++局面数量;
  无符号 字节 对方=反转阵营(走棋方),剩余深度=目标深度-目前深度,多搜=0;

  auto 查找结果=置换表.find(局面键);
  搜索信息 暂存;
  如果(查找结果!=置换表.end()) {
    暂存=(*查找结果).second ;
    if(暂存.深度>=剩余深度) {//cin.get();
      if(暂存.类型==符合预期 or
          (暂存.类型==高于预期 and
           暂存.分数>=贝塔)or
          (暂存.类型==低于预期 and
           暂存.分数<=阿尔法)) {
        ++置换次数;
        返回 暂存.分数;
      }
    }
    //杀手启发[目前深度][1]=杀手启发[目前深度][0];
    杀手启发[目前深度][0]=暂存.最好走法;
    ++置换启发次数;
  }//杀手启发[目前深度][0]=暂存.最好走法;

  int 最优值=输,备份;
  if(目前深度>=目标深度) {
    //返回 审局(走棋方);
    返回 静态搜索(阿尔法,贝塔,目前深度, 走棋方);
    最优值= 静态搜索(阿尔法,贝塔,目前深度, 走棋方);
    暂存.类型=符合预期;
    //goto 保存;
  }
  int 分数;
  //*空着裁剪
  if(非空着 and 目前深度>0
      //and 目前深度<目标深度-1
    ) {
    //++局面数量;
    非空着=假;
    局面键[90]=对方;
    分数 = -阿尔法贝塔搜索(-贝塔,-贝塔+1,目标深度,对方,目标深度);
    局面键[90]=走棋方;
    非空着=真;
    if(分数>=贝塔) {
      返回 分数;
      最优值= 分数;
      暂存.类型=高于预期;
      //goto 保存;
    }
  }//*/

  棋子 移动棋子,被吃棋子;
  char 走法数量=获取走法(走棋方,目前深度);
  走法排序(目前深度,走法数量);
  暂存.类型=低于预期;
  for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
  {
    走法 &走法=走法列表[目前深度][走法下标];
    //#define 走法 走法列表[目前深度][走法下标]
    /*
       if(!走法在棋盘(走法)){
       显名值(目前深度)显名值(分数)显名值(最优值)
       显名值(阿尔法)显名值(贝塔)显名值(走法数量)
       显名值(走法下标)显示走法(走法)显名值(备份)
       cin.get();}
    //*/
    被吃棋子=局面[走法.终.纵][走法.终.横];
    if(被吃棋子.兵种==将) {
      分数=赢-目前深度;
    }
    else {
      移动棋子=局面[走法.起.纵][走法.起.横];

      //走棋
      局面[走法.起.纵][走法.起.横]=空棋子;
      局面[走法.终.纵][走法.终.横]=移动棋子;
      局面键[一维坐标[走法.起.纵][走法.起.横]]=空;
      局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种);
      局面键[90]=对方;
      备份=红减黑分数;
      红减黑分数=红减黑分数-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
      //多搜=被吃棋子.兵种!=空;//写<<(int)多搜;cin.get();
      if(pvs and          暂存.类型==符合预期        ) {
        分数 = - 阿尔法贝塔搜索(-阿尔法-1,-阿尔法,目前深度+1,对方,目标深度+多搜);
        if(阿尔法<分数 and 分数<贝塔)        {   
          int 突破=分数;
          分数 = - 阿尔法贝塔搜索(-贝塔,-阿尔法,目前深度+1,对方,目标深度+多搜);
          if(分数<突破) {
            写<<"错误";显名值(阿尔法)显名值(突破)显名值(分数)
              //cin.get();
          }
        }
      }      else {
        分数 = - 阿尔法贝塔搜索(- 贝塔,- 阿尔法,目前深度+1,对方,目标深度+多搜);
      }
      //悔棋
      局面[走法.起.纵][走法.起.横]=移动棋子;
      局面[走法.终.纵][走法.终.横]=被吃棋子;
      局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
      局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
      局面键[90]=走棋方;
      红减黑分数=备份;
      if(clock()-开始>限时) {
        时间到=真;
        暂存.类型=没搜完;
        if(走法下标==0) {
          最优值 = 暂存.分数;
        }
        break;
      }
    }

    if(分数>最优值) {
      最优值 = 分数;
      暂存.最好走法= 走法;

      if(分数>=贝塔) {
        //++历史分(走法);
        历史分(走法)+=剩余深度;//*剩余深度;
                               //杀手启发[目前深度][1]=杀手启发[目前深度][0];
        杀手启发[目前深度][0]=走法;
        ++杀手启发次数;
        暂存.类型=高于预期;
        break;
      }
      if(分数>阿尔法) {
        阿尔法=分数;
        暂存.类型=符合预期;
      }
    }
  }
  ++历史分(暂存.最好走法);
  ++历史启发次数;
  //历史分(暂存.最好走法)+=剩余深度;

  保存://*
    暂存.深度=剩余深度;
  暂存.分数=最优值;
  置换表[局面键]=暂存;
  ++保存次数;//*/
  返回 最优值;
}
//#undef 走法
常量 字符串 零到九[]= {"零","一","二","三","四","五","六","七","八","九"};
字符串 红黑数字文本(字节 阵营,字节 数字,bool 是横) {
  返回 (数字<=9 ?
      (阵营==黑方 ?
       to_string(数字) : 零到九[是横 ? 10-数字 : 数字]):"错误走法");
}
字符串 走法文本(走法 走法) {
  棋子 子=取棋子(走法.起);
  if((!走法在棋盘(走法)) or 子.阵营==空) {
    写<<"错误走法";
    读.get();
  }
  字符串 着法=棋值(子,棋子文本)+红黑数字文本(子.阵营,走法.起.横+1,真);
  if(走法.起.纵==走法.终.纵) {
    着法+="平";
  } else if((走法.起.纵<走法.终.纵)==(子.阵营==黑方))
  {
    着法+="进";
  }
  else {
    着法+="退";
  }
  if(走法.起.横==走法.终.横) {
    着法+=红黑数字文本(子.阵营,绝对值(走法.起.纵-走法.终.纵),假);
  }
  else {
    着法+=红黑数字文本(子.阵营,走法.终.横+1,真);
  }
  返回 着法;
}
#define 宏走棋(走法) \
    棋子 被吃棋子=局面[走法.终.纵][走法.终.横],移动棋子=局面[走法.起.纵][走法.起.横]; \
      局面[走法.起.纵][走法.起.横]=空棋子; \
      局面[走法.终.纵][走法.终.横]=移动棋子; \
      局面键[一维坐标[走法.起.纵][走法.起.横]]=空; \
      局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种); \
      局面键[90]=反转阵营(局面键[90]);
      
走法 对策;
void 显示变例(字节 下标) {
  if(下标<预期深度) {
    auto 查找结果=置换表.find(局面键);
    if(查找结果!=置换表.end()) {
      搜索信息 暂存=(*查找结果).second ;
      走法 &走法=暂存.最好走法;
      如果(下标==0){对策=走法;}
      写<<下标+1<<"(";
      //显示走法(走法)
      写<<走法文本(走法)<<") ";
      
      宏走棋(走法)
      
      显示变例(下标+1);//递归
                       //悔棋
      局面[走法.起.纵][走法.起.横]=移动棋子;
      局面[走法.终.纵][走法.终.横]=被吃棋子;
      局面键[一维坐标[走法.起.纵][走法.起.横]]=棋值(移动棋子,红黑兵种);
      局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(被吃棋子,红黑兵种);
      局面键[90]=反转阵营(局面键[90]);
    }
  }
}
bool 走法错误;
void 显示所有走法(字节 走棋方){
    写<<"现在可走：";
      int 目前深度=0,走法数量=获取走法(走棋方,目前深度);
  //走法排序(目前深度,走法数量);
  走法 走法;
  for(char 走法下标=0; 走法下标<走法数量; ++走法下标)
  {
    走法=走法列表[目前深度][走法下标];
    写<<走法下标+1<<"("<<走法文本(走法)<<") ";
        
  }
  int 走法序号;
  
  do{
      换行()
   写<<"你选择：";
   读>>走法序号;
   如果(走法序号<1 or 走法序号>走法数量){
      走法错误=真;
      写<<"走法错误!";//<<走法数量;
      返回;
   }else{走法错误=假;
       走法=走法列表[目前深度][走法序号-1];
       写<<走法文本(走法);
       换行()
       宏走棋(走法)
       红减黑分数=红减黑分数-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
       该走方=反转阵营(该走方);
       显示局面();
   }
  }while(走法错误);
}
int MTDF(int 猜测, int 深度) {
  int 分数, 贝塔, 顶, 底;
  分数 = 猜测;
  顶 = 赢;
  底 = 输;
  换行()写<<"MTDF搜索";
  //显名值(深度)
  do {
    贝塔 = (分数 == 底 ? 分数 + 1 : 分数);
    分数 = 阿尔法贝塔搜索( 贝塔 - 1, 贝塔,0,该走方,深度);
    显名值(分数)
    (分数 < 贝塔 ? 顶 : 底) = 分数;
  } while (底 < 顶);
  return 分数;
}

int 期望搜索(int 猜测,int 深度) {
  int 顶,底,分数;
  换行()写<<"期望搜索";显名值(猜测)
  窗口:
    顶=猜测+1;底=猜测-1;
  //显名值(深度)
  bool 最后一次=假;
  for(;;) {
    分数=阿尔法贝塔搜索(底,顶,0,该走方,深度);
    显名值(分数)
    //if(分数!=猜测){猜测=分数;goto 窗口;}返回 分数;
    如果(最后一次){返回 分数;}
    if(分数>=顶) {
      底=分数-1;
      顶=赢;
      最后一次=真;
    }
    else if(分数<=底) {
      顶=分数+1;
      底=输;
      最后一次=真;
    }
    else {
      返回 分数;
    }
  }
}
#define 是否结束() \
分数=是否绝杀(输,赢,0,该走方);\
如果(绝对值(分数)>必杀){写<<(该走方==红方 ? "红" : "黑")<<"方"<<(分数>0 ? "胜!" : "负!");换行()break;}
int main()
{   ios::sync_with_stdio(假);
  time_t 秒;
#define 显示时间() time(&秒);写<<ctime(&秒);
  初始化();
  开局赋值();
  bool 胜负未分=真;int 分数,猜测=0;字符串 文本=局面键;
  do{
  显示局面();
  是否结束()
显示所有走法(该走方);
如果(走法错误){写<<"程序退出...";换行()返回 4; }
是否结束()
  
  

  显示时间()
    /*
       写<<"\u4f60\u597d\U0001f60a\U0001f601";
       显名值(UINT_MAX)//显名值(1 and 1)
       显名值(文本.size())显名值(sizeof(文本))
       读.get();
    //*/
    开始 = clock();
  限时=(10-0.01)*CLOCKS_PER_SEC;//秒
  保存次数=置换次数=历史启发次数=杀手启发次数=置换启发次数=局面数量=0;
  时间到=假;
  非空着=真;
  pvs=假;
  //迭代深化
  for(预期深度=1; 预期深度<=68; ++预期深度) {

    //分数=阿尔法贝塔搜索(输,赢,0,该走方,预期深度);
    分数=期望搜索(猜测,预期深度);
    //分数=MTDF(猜测,预期深度);
    猜测=分数;
    用时=(clock()-开始)+1;
    用时/=CLOCKS_PER_SEC;
    显名值(pvs)
      写<<"\n 搜索深度"<<预期深度<<" 分数"<< 分数
      <<" 局面数量"<<局面数量<<" 用时"
      <<用时<<"秒"<<" nps:"<<局面数量/用时/1000<<"k";
    显名值(历史启发次数)显名值(杀手启发次数)显名值(置换启发次数)显名值(保存次数)显名值(置换表.size())显名值(置换次数)
      写<<"\n 主变例:";
    显示变例(0);
    写<<endl;

    if(时间到 or 绝对值(分数)>赢-100)break;
  }
  宏走棋(对策)
  走法 走法=对策;
  红减黑分数=红减黑分数-棋位分(移动棋子,走法.起)+棋位分(移动棋子,走法.终)-棋位分(被吃棋子,走法.终);
       该走方=反转阵营(该走方);
  换行()
  }while(胜负未分);
  显示时间()
#ifdef _WIN32
  写<<"可回车退出...";
  读.get();
#endif
  //pause();//system("PAUSE");
  返回 0;
}
