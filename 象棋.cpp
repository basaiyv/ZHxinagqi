#include <iostream>
#include <string>
#include <ctime>
//#include <unistd.h>
#include <cmath>
#include <climits>
#include <map>
#include <unordered_map>
//#include <hash_map>
#include <thread>
#include <array>
#include <sstream>

#ifdef _WIN32
#include <windows.h>
#endif

//#define  ！  !
#define 使用 using
#define 命名空间 namespace
使用 命名空间 std;
#define 整数 int
#define 主函数 main
#define 读 cin
#define 写 cout
#define 返回 return
#define 如果 if
#define 否则 else
#define 真 true
#define 假 false
#define 且 and
#define 或 or
#define 空型 void
#define 常量 const
#define 有符号 signed
#define 无符号 unsigned
//typedef char 字节;
#define 字节 int8_t
#define 正字节 uint8_t
//typedef string 字符串;
#define 字符串 string
#define 文本 string
#define 交换 swap

#define 模板 template
#define 类 class
/*   模板 <类 数字>
   数字 绝对值(数字 数) {
   返回 数<0 ? -数 : 数;
   }*/
#define 绝对值(数) ((数)<0 ? -(数) : (数))
#define 最大(甲,乙) ((甲)>(乙) ? (甲) : (乙))
#define 最小(甲,乙) ((甲)<(乙) ? (甲) : (乙))

#define 等待回车() cin.get();

常量 字符串 开局FEN = "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w";
bool 走法错误, 人机对弈 = 真;
int 保存次数, 置换次数, pvs假突破次数;
bool pvs = 真,
//
可空着 = 真;
//可空着 = 假;
#define 取现在系统时间() std::chrono::steady_clock::now()
#define 转毫秒(时间) std::chrono::duration_cast < std::chrono::milliseconds > (时间).count()
auto 开始时间 = 取现在系统时间();
clock_t
用时毫秒,
限时毫秒, 每秒计时单元数 = CLOCKS_PER_SEC, 每毫秒计时单元数 = 每秒计时单元数/1000;
bool 没完 = 真;
#define 控1位 50

字节 该走方, 棋子数量;
void 局面设置(常量 字符串& fen);

常量 字符串 横 = "一", 竖 = "丨",
默认 = "\e[0m",
白背黑字 = "\e[47;30m",
黑 = "\e[30m",
红 = "\e[31m",
黄 = "\e[33m",
蓝 = "\e[34m",
绿 = "\e[32m";
string 彩字(string 颜色码, string 字符) {
  返回 颜色码+字符+黑;
}
#define 红字(字) 彩字(红,字)
#define 黄字(字) 彩字(黄,字)
#define 蓝字(字) 彩字(蓝,字)
#define 绿字(字) 彩字(绿,字)
#define 重复(次数,语句...) \
for (int 数=1; 数 <= 次数; ++数) {语句}
#define 遍历(成员数,语句...) \
for (int 下标=0; 下标 < 成员数; ++下标) {语句}
#define 无限循环(代码...) for(;;){代码}
#define 换行() 写<<endl;

常量 字节 棋盘顶 = 0, 棋盘底 = 9, 棋盘左 = 0, 棋盘右 = 8, 中线 = 4,
黑方河界 = 4, 红方河界 = 5, 九宫左 = 3, 九宫右 = 5;

#define 空 0

//兵种
#define 将 1// 或 帅
#define 车 2
#define 马 3
#define 炮 4
#define 士 5// 或 仕
#define 象 6// 或 相
#define 卒 7// 或 兵

//阵营
#define 黑方 1//显示为蓝色
#define 红方 2

#define 红加黑 3
#define 反转阵营(阵营) (红加黑-(阵营))

//红黑兵种
#define 黑将 1// 或 帅
#define 黑车 2
#define 黑马 3
#define 黑炮 4
#define 黑士 5// 或 仕
#define 黑象 6// 或 相
#define 黑卒 7// 或 兵

#define 红将 8// 或 帅
#define 红车 9
#define 红马 10
#define 红炮 11
#define 红士 12// 或 仕
#define 红象 13// 或 相
#define 红卒 14// 或 兵

#define 取阵营(红黑兵种) (红黑兵种==空 ? 空 : (红黑兵种<红将 ? 黑方 : 红方))
#define 取兵种(红黑兵种) (红黑兵种 < 红将 ? 红黑兵种 : 红黑兵种-7)

#define 显名值(表达式) \
写<<" "<<#表达式<<":"<<(sizeof(表达式)==1 ? 0+(表达式) : (表达式))<<" ";
time_t 秒;
#define 显示时间() time(&秒);写<<ctime(&秒);
#define 赢 10001.0
#define 输 -赢
#define 必杀 (赢-100)
struct 位置 {
  正字节 纵 = 0; //无符号避免小于0
  正字节 横 = 0;
};
struct 走法 {
  位置 起;
  位置 终;
  int 排序分 = INT_MIN;
};
走法 走法列表[100][110], 置换表启发[100][3], 杀手启发[100][3];
走法 对策;
字符串 取走法文本(走法 走法);
#define 纵在棋盘(纵) (纵<10)
#define 横在棋盘(横) (横<9)
#define 位置在棋盘(位) (纵在棋盘(位.纵) 且 横在棋盘(位.横))
#define 走法在棋盘(走法) (位置在棋盘(走法.起) 且 位置在棋盘(走法.终))
#define 位置相等吗(位1,位2) (位1.纵 == 位2.纵 且 位1.横 == 位2.横)
#define 走法相等吗(走法1,走法2) (位置相等吗(走法1.起,走法2.起) 且 位置相等吗(走法2.终,走法1.终))

#define 显示走法(走法) \
写<<"起:纵"<<(int)走法.起.纵+1<<"横"<<(int)走法.起.横+1<<",终:纵" \
<<(int)走法.终.纵+1<<"横"<<(int)走法.终.横+1;

struct 棋子 {
  char 阵营 = 空;
  char 兵种 = 空;
}空棋子, 局面[10][9], 空局面[10][9];
#define 取棋子(位) 局面[位.纵][位.横]
#define 置换表长度 (1024*1024)
int32_t 历史启发[10][9][10][9], 历史启发次数, 杀手启发次数, 置换启发次数, 备份杀手分[3], 备份置换分[3], 历史分上限 = (1<<30);
uint32_t Zobrist局面键, Zobrist哈希数组[15][10][9];
uint64_t Zobrist校验数组[15][10][9], Zobrist局面验;
#define 历史分(走法) 历史启发[走法.起.纵][走法.起.横][走法.终.纵][走法.终.横]

空型 间隙() {
  写 <<" " << 竖;
  重复(8,
    写 << "  "<<竖;)
  写 << endl;
}

字符串 棋子文本[3][8]; //[阵营][兵种]

空型 显示棋子(棋子 棋子) {
  写<<棋子文本[棋子.阵营][棋子.兵种];
}

空型 显示行(char 纵下标) {
  写 <<" "; 显示棋子(局面[纵下标][0]);
  重复(8,
    写 << 横;
    显示棋子(局面[纵下标][数]);)
  写 << endl;
}

空型 九宫间隙(string 斜杠1, string 斜杠2) {
  写 <<" "<< 竖;
  重复(3, 写 << "  "<<竖;)
  写 << 斜杠1+竖+斜杠2+竖;
  重复(3, 写 << "  "<<竖;)
  写 << endl;
}
int 红减黑分数, 棋子位置分数[3][8][10][9] = {}, 兵种分[8];
int 未吃子步数 = 0;
#define 审局(分数方) ((分数方) == 红方 ? 红减黑分数 : (- 红减黑分数))
int 静态搜索(int 阿尔法, int 贝塔, 正字节 现在深度, char 走棋方);
空型 显示局面() {
  写 << "     中      国      象      棋    " << endl;
  写 << " １  ２  ３  ４  ５  ６  ７  ８  ９" << endl; //全角数字
  显示行(0);
  九宫间隙("＼", "／");
  显示行(1);
  九宫间隙("／", "＼");
  显示行(2);
  间隙();
  显示行(3);
  间隙();
  显示行(4);
  写 <<" "<<竖<<"  楚      河      汉      界  "<< 竖<<endl;
  显示行(5);
  间隙();
  显示行(6);
  间隙();
  显示行(7);
  九宫间隙("＼", "／");
  显示行(8);
  九宫间隙("／", "＼");
  显示行(9);
  写 << " 九  八  七  六  五  四  三  二  一" << endl;
  写<<(该走方 == 红方 ? "该红走": "该黑走");
  显名值(审局(红方))
  显名值(未吃子步数)
  显名值(棋子数量)
  显名值(Zobrist局面键)
  显名值(Zobrist局面验)
  //显名值(静态搜索(输, 审局(该走方)+1, 0, 该走方))
  换行()
  显示时间()
  //换行()
  写<<"象棋方程组,作者方程组.开源网址 github.com/bcfcz/- .这是中国象棋uci引擎程序,请用中国象棋界面程序调用.";
  换行()
}

#define 棋位分(棋子,位置) 棋子位置分数[棋子.阵营][棋子.兵种][位置.纵][位置.横]
字节 红黑兵种[3][8], 一维坐标[10][9];
#define 棋值(棋子,数组) 数组[棋子.阵营][棋子.兵种]
#define 最低0(数) ((数)<0 ? 0 : (数))
整数 马位可能走法数(位置 起点) {
  整数 上,
  下,
  左,
  右;
  上 = 下 = 左 = 右 = 2;
  如果(起点.纵 < 棋盘顶+2) {
    上 -= 2;
  }
  如果(起点.纵 > 棋盘底-2) {
    下 -= 2;
  }
  如果(起点.横 < 棋盘左+2) {
    左 -= 2;
  }
  如果(起点.横 > 棋盘右-2) {
    右 -= 2;
  }
  如果(起点.纵 == 棋盘顶 或 起点.纵 == 棋盘底) {
    左 = 最低0(左-1);
    右 = 最低0(右-1);
  }
  如果(起点.横 == 棋盘左 或 起点.横 == 棋盘右) {
    上 = 最低0(上-1);
    下 = 最低0(下-1);
  }
  返回 上+下+左+右;
}

字符串 局面键 (91, (char)空);
空型 开局赋值() {
  局面设置(开局FEN);
  if(红减黑分数 != 0) {
    写<<"初始化分数错误";
    cin.get();
  }
}
整数 威胁保护分, 空头分, 各层威胁保护分[100], 各层空头分[100];
//if(!走法在棋盘(走法)){显名值(现在深度)显名值()显示棋子(起点棋子);显示走法(走法)cin.get();}
#define 加入走法() \
走法列表[现在深度][走法数量]=走法; ++走法数量;

#define 没吃友军走法() \
if(取棋子(走法.终).阵营!=走棋方) { \
if(取棋子(走法.终).兵种==将) \
{走法列表[现在深度][0]=走法;返回 1;}\
加入走法()if(取棋子(走法.终).阵营!=空)威胁保护分+=3;}else 威胁保护分+=2;

#define 车走法() \
没吃友军走法() \
if(取棋子(走法.终).阵营!=空){break;}

#define 炮走法() \
if(取棋子(走法.终).阵营!=空) { \
if(隔子==1){没吃友军走法() break;}\
否则 如果(取棋子(走法.终).兵种==将 且 取棋子(走法.终).阵营!=走棋方 ){空头分+=控1位*5;}\
++隔子;\
}else{if(隔子==0){加入走法()}}

#define 马走法(长纵横,长加减,长限制,短纵横,短上限) \
走法.终.长纵横 = 走法.起.长纵横 长加减 2; \
if(走法.终.长纵横 长限制) { \
阻.长纵横=走法.起.长纵横 长加减 1; \
阻.短纵横=走法.起.短纵横; \
if(取棋子(阻).阵营==空) { \
走法.终.短纵横=走法.起.短纵横+1; \
if(走法.终.短纵横 <= 短上限) { \
没吃友军走法() \
} \
走法.终.短纵横=走法.起.短纵横-1; \
if(走法.终.短纵横 <= 短上限) { \
没吃友军走法() \
} \
} \
}
char 获取走法(char 走棋方, 无符号 char 现在深度) {
  威胁保护分 = 空头分 = 0;
  char 走法数量 = 0,
  隔子,
  九宫顶,
  九宫底,
  己方顶,
  己方底,
  前进;
  走法 走法;
  位置 阻;
  if(走棋方 == 红方) {
    九宫顶 = 7;
    九宫底 = 9;
    己方顶 = 5;
    己方底 = 9;
    前进 = -1;
  }
  else {
    //黑方
    九宫顶 = 0;
    九宫底 = 2;
    己方顶 = 0;
    己方底 = 4;
    前进 = 1;
  }

  棋子 起点棋子;
  for(走法.起.纵 = 0; 走法.起.纵 < 10; ++走法.起.纵) {
    for(走法.起.横 = 0; 走法.起.横 < 9; ++走法.起.横) {

      起点棋子 = 取棋子(走法.起);
      if(起点棋子.阵营 == 走棋方) {
        //写<<"起点棋子.兵种"<<起点棋子.兵种+0;

        if(起点棋子.兵种 == 车) {
          走法.终.纵 = 走法.起.纵;
          for(走法.终.横 = 走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
            车走法()
          }
          for(走法.终.横 = 走法.起.横-1; 走法.终.横 < 9; --走法.终.横) {
            车走法()
          }
          走法.终.横 = 走法.起.横;
          for(走法.终.纵 = 走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
            车走法()
          }
          for(走法.终.纵 = 走法.起.纵-1; 走法.终.纵 < 10; --走法.终.纵) {
            车走法()
          }
        } else if(起点棋子.兵种 == 炮) {
          走法.终.纵 = 走法.起.纵;
          隔子 = 0;
          for(走法.终.横 = 走法.起.横+1; 走法.终.横 < 9; ++走法.终.横) {
            炮走法()
          }
          隔子 = 0;
          for(走法.终.横 = 走法.起.横-1; 走法.终.横 < 9; --走法.终.横) {
            炮走法()
          }
          走法.终.横 = 走法.起.横;
          隔子 = 0;
          for(走法.终.纵 = 走法.起.纵+1; 走法.终.纵 < 10; ++走法.终.纵) {
            炮走法()
          }
          隔子 = 0;
          for(走法.终.纵 = 走法.起.纵-1; 走法.终.纵 < 10; --走法.终.纵) {
            炮走法()
          }
        } else if(起点棋子.兵种 == 卒) {
          //过河了
          if(起点棋子.阵营 == 红方 ?
            走法.起.纵 < 红方河界:
            走法.起.纵 > 黑方河界) {
            走法.终.纵 = 走法.起.纵;

            if(走法.起.横 < 8) {
              走法.终.横 = 走法.起.横+1;
              没吃友军走法()
            }

            if(走法.起.横 > 0) {
              走法.终.横 = 走法.起.横-1;
              没吃友军走法()
            }
          }
          走法.终.横 = 走法.起.横; //不能后退
          if(起点棋子.阵营 == 黑方) {
            if(走法.起.纵 < 9) {
              走法.终.纵 = 走法.起.纵+1;
              没吃友军走法()
            }
          } else {
            if(走法.起.纵 > 0) {
              走法.终.纵 = 走法.起.纵-1;
              没吃友军走法()
            }
          }


        } else if(起点棋子.兵种 == 士) {
          //不能出九宫
          #define 士上(嵌套)\
          if(走法.起.纵>九宫顶)\
          {走法.终.纵=走法.起.纵-1;\
          嵌套}

          #define 士下(嵌套)\
          if(走法.起.纵<九宫底)\
          {走法.终.纵=走法.起.纵+1;\
          嵌套}

          if(走法.起.横 > 九宫左) {
            走法.终.横 = 走法.起.横-1;
            士下(没吃友军走法())
            士上(没吃友军走法())
          }

          if(走法.起.横 < 九宫右) {
            走法.终.横 = 走法.起.横+1;
            士下(没吃友军走法())
            士上(没吃友军走法())
          }

        } else if(起点棋子.兵种 == 象) {
          //不能过河
          #define 象眼() \
          if(局面[阻.纵][阻.横].阵营==空)\
          {               没吃友军走法()}

          #define 象上(嵌套)\
          if(走法.起.纵>己方顶)\
          {走法.终.纵=走法.起.纵-2;\
          阻.纵=走法.起.纵-1; 嵌套}

          #define 象下(嵌套)\
          if(走法.起.纵<己方底)\
          {走法.终.纵=走法.起.纵+2;\
          阻.纵=走法.起.纵+1; 嵌套}

          if(走法.起.横 > 棋盘左) {
            走法.终.横 = 走法.起.横-2;
            阻.横 = 走法.起.横-1;
            象下(象眼())
            象上(象眼())
          }

          if(走法.起.横 < 棋盘右) {
            走法.终.横 = 走法.起.横+2;
            阻.横 = 走法.起.横+1;
            象下(象眼())
            象上(象眼())
          }



        } else if(起点棋子.兵种 == 马) {

          马走法(纵, -, < 10, 横, 8)马走法(纵, +, <= 9, 横, 8)
          马走法(横, -, < 9, 纵, 9)马走法(横, +, <= 8, 纵, 9)

        } else if(起点棋子.兵种 == 将) {
          //不能出九宫,除非将帅对面
          走法.终.纵 = 走法.起.纵;
          if(走法.起.横 < 九宫右) {
            走法.终.横 = 走法.起.横+1;
            没吃友军走法()
          }
          if(走法.起.横 > 九宫左) {
            走法.终.横 = 走法.起.横-1;
            没吃友军走法()
          }

          走法.终.横 = 走法.起.横;
          if(走法.起.纵 < 九宫底) {
            走法.终.纵 = 走法.起.纵+1;
            没吃友军走法()
          }
          if(走法.起.纵 > 九宫顶) {
            走法.终.纵 = 走法.起.纵-1;
            没吃友军走法()
          }
          for(走法.终.纵 = 7-九宫顶; 走法.终.纵 <= 11-九宫底; ++走法.终.纵) {
            //对方九宫
            if(取棋子(走法.终).兵种 == 将) {
              阻.横 = 走法.起.横;
              for(阻.纵 = 走法.起.纵+前进; 阻.纵 != 走法.终.纵; 阻.纵 += 前进) {
                if(取棋子(阻).阵营 != 空) {
                  goto 兵种结束;
                }
              }
              //将帅对面
              走法列表[现在深度][0] = 走法;
              返回 1;
            }
          }
          /*
          for(走法.终.纵 = 走法.起.纵+前进; 纵在棋盘(走法.终.纵); 走法.终.纵 += 前进) {
            //往前
            如果(取棋子(走法.终).兵种 == 炮 且 取棋子(走法.终).阵营 != 走棋方) {
              //被空头
              空头分 -= 控1位*5;
            }\

            if(取棋子(走法.终).兵种 != 空) {
              break;
            }
          }*/
        }
        兵种结束:;
      }
    }
  }
  //cin.get();
  退出:
  各层空头分[现在深度] = 空头分;
  各层威胁保护分[现在深度] = 威胁保护分;
  返回 走法数量;
}

struct 搜索信息 {
  uint64_t 验 = 0;
  字节 深度 = 0;
  int 分数;
  字节 类型,
  棋子数量;
  走法 最好走法,
  第二走法,
  第三走法;
} Zobrist置换表[2*置换表长度], Zobrist置换表深度优先[2*置换表长度];

#define 马物质权重 1
#define 马空间权重 (1-马物质权重)
#define 士象物质权重 (0.7*1)
#define 士象空间权重 (0.7-士象物质权重)
#define 遍历下标(下标类型,下标名,下标数量,代码...) for(下标类型 下标名=0; 下标名<下标数量;++下标名){代码}
空型 初始化() {
  //Zobrist置换表 = new 搜索信息[2*置换表长度];

  走法 走;
  遍历下标(, 走.起.纵, 10,
    遍历下标(, 走.起.横, 9,
      遍历下标(, 走.终.纵, 10,
        遍历下标(, 走.终.横, 9,
          历史分(走) = INT_MIN;))))

  写<<白背黑字;
  遍历(8, 红黑兵种[空][下标] = 空;)
  重复(2, 红黑兵种[数][空] = 空;)
  红黑兵种[黑方][将] = 黑将;
  红黑兵种[黑方][车] = 黑车;
  红黑兵种[黑方][马] = 黑马;
  红黑兵种[黑方][炮] = 黑炮;
  红黑兵种[黑方][士] = 黑士;
  红黑兵种[黑方][象] = 黑象;
  红黑兵种[黑方][卒] = 黑卒;

  红黑兵种[红方][将] = 红将;
  红黑兵种[红方][车] = 红车;
  红黑兵种[红方][马] = 红马;
  红黑兵种[红方][炮] = 红炮;
  红黑兵种[红方][士] = 红士;
  红黑兵种[红方][象] = 红象;
  红黑兵种[红方][卒] = 红卒;

  遍历(8, 棋子文本[空][下标] = "  ";)
  重复(2, 棋子文本[数][空] = "  ";)
  棋子文本[黑方][将] = 蓝字("将");
  棋子文本[黑方][车] = 蓝字("车");
  棋子文本[黑方][马] = 蓝字("马");
  棋子文本[黑方][炮] = 蓝字("炮");
  棋子文本[黑方][士] = 蓝字("士");
  棋子文本[黑方][象] = 蓝字("象");
  棋子文本[黑方][卒] = 蓝字("卒");

  棋子文本[红方][将] = 红字("帅");
  棋子文本[红方][车] = 红字("车");
  棋子文本[红方][马] = 红字("马");
  棋子文本[红方][炮] = 红字("炮");
  棋子文本[红方][士] = 红字("仕");
  棋子文本[红方][象] = 红字("相");
  棋子文本[红方][卒] = 红字("兵");

  兵种分[空] = 0;
  兵种分[将] = 赢;
  兵种分[车] = (9+8)*控1位;
  兵种分[炮] = (9+8)*控1位/2;
  兵种分[马] = (8)*控1位;
  兵种分[士] = (4)*控1位+5;
  兵种分[象] = (4)*控1位+7;
  兵种分[卒] = (1)*控1位+9;

  棋子 子;
  位置 位,
  将原位,
  帅原位,
  中象位,
  中相位;

  将原位.横 = 帅原位.横 = 中象位.横 = 中相位.横 = 中线;
  将原位.纵 = 0;
  帅原位.纵 = 9;
  中象位.纵 = 2;
  中相位.纵 = 7;

  #define 取距离分(位1,位2) \
  ((9-绝对值(位1.纵-位2.纵))*9+(4-绝对值(位1.横-位2.横))*10)
  #define 取兵卒距离分(位1,位2) \
  ((4-绝对值(位1.纵-位2.纵))*9+(4-绝对值(位1.横-位2.横))*10)
  #define 取炮距离分(位1,位2) \
  ((9-绝对值(位1.纵-位2.纵))*1+(4-绝对值(位1.横-位2.横))*2)

  字节 下标 = 0,
  走法数量;
  map < uint64_t,bool > 已用数;

  srand(20230903); //随机数种子

  uint32_t 随机数;
  uint64_t 随机数64位;

  for(位.纵 = 0; 位.纵 <= 9; ++位.纵) {
    for(位.横 = 0; 位.横 <= 8; ++位.横) {
      一维坐标[位.纵][位.横] = 下标;
      ++下标;

      Zobrist哈希数组[空][位.纵][位.横] = 0;
      Zobrist校验数组[空][位.纵][位.横] = 0;
      for(字节 棋号 = 1; 棋号 <= 14; ++棋号) {
        
        do{
          随机数 = rand();
          }while(随机数 < 1 或 已用数.find(随机数) != 已用数.end());
        已用数[随机数] = 真;
        Zobrist哈希数组[棋号][位.纵][位.横] = 随机数;

        无限循环(
          随机数64位 = rand();
          如果(随机数64位 > 0 且 已用数.find(随机数64位) == 已用数.end())
          break;
          //否则
          //写<<"重复数";
        )
        已用数[随机数64位] = 真;
        Zobrist校验数组[棋号][位.纵][位.横] = 随机数64位;
      }

      子.阵营 = 红方;
      子.兵种 = 将;
      棋位分(子, 位) = 赢+取距离分(位, 帅原位);
      子.兵种 = 车;
      棋位分(子, 位) = 兵种分[车]+取距离分(位, 将原位);
      子.兵种 = 炮;
      棋位分(子, 位) = 兵种分[炮]+取炮距离分(位, 将原位);
      子.兵种 = 马;
      棋位分(子, 位) = 8*控1位*马物质权重+控1位*马位可能走法数(位)*马空间权重+取兵卒距离分(位, 将原位);
      子.兵种 = 士;
      棋位分(子, 位) = 5+4*控1位*士象物质权重+控1位*(位.横 == 中线 ? 4: 1)*士象空间权重+取炮距离分(位, 帅原位);
      子.兵种 = 象;
      棋位分(子, 位) = 7+4*控1位*士象物质权重+控1位*(位.横 == 中线 ? 4: 2)*士象空间权重+取炮距离分(位, 帅原位);
      子.兵种 = 卒;
      取棋子(位) = 子;
      走法数量 = 获取走法(子.阵营, 0);
      棋位分(子, 位) = 走法数量*控1位+9+取兵卒距离分(位, 中象位);

      子.阵营 = 黑方;
      子.兵种 = 将;
      棋位分(子, 位) -= 赢+取距离分(位, 将原位);
      子.兵种 = 车;
      棋位分(子, 位) -= 兵种分[车]+取距离分(位, 帅原位);
      子.兵种 = 炮;
      棋位分(子, 位) -= 兵种分[炮]+取炮距离分(位, 帅原位);
      子.兵种 = 马;
      棋位分(子, 位) -= 8*控1位*马物质权重+控1位*马位可能走法数(位)*马空间权重+取兵卒距离分(位, 帅原位);
      子.兵种 = 士;
      棋位分(子, 位) -= 5+4*控1位*士象物质权重+控1位*(位.横 == 中线 ? 4: 1)*士象空间权重+取炮距离分(位, 将原位);
      子.兵种 = 象;
      棋位分(子, 位) -= 7+4*控1位*士象物质权重+控1位*(位.横 == 中线 ? 4: 2)*士象空间权重+取炮距离分(位, 将原位);
      子.兵种 = 卒;
      取棋子(位) = 子;
      走法数量 = 获取走法(子.阵营, 0);
      棋位分(子, 位) -= 走法数量*控1位+9+取兵卒距离分(位, 中相位);

      取棋子(位) = 空棋子;
    }
  }

  /*中炮
      子.兵种 = 炮;
      位.横 = 中线;
      for(位.纵 = 0; 位.纵 <= 9; ++位.纵) {
          子.阵营 = 红方;
          棋位分(子, 位) += 控1位;

          子.阵营 = 黑方;
          棋位分(子, 位) -= 控1位;
      }//*/

  /*/底炮
      for(位.横=0; 位.横<=8; ++位.横) {
          子.阵营=红方;
          位.纵=棋盘顶;
          棋位分(子,位)+=控1位;
          子.阵营=黑方;
          位.纵=棋盘底;
          棋位分(子,位)-=控1位;
      }*/

  //窝心
  子.阵营 = 红方;
  子.兵种 = 马;
  位.纵 = 8;
  位.横 = 中线;
  棋位分(子, 位) -= 控1位*2;
  //*
  子.兵种 = 车;
  棋位分(子, 位) -= 控1位;
  //*
  子.兵种 = 炮;
  棋位分(子, 位) -= 控1位/2;
  //*/
  子.阵营 = 黑方;
  子.兵种 = 马;
  位.纵 = 1;
  棋位分(子, 位) += 控1位*2;
  //*
  子.兵种 = 车;
  棋位分(子, 位) += 控1位;
  //*
  子.兵种 = 炮;
  棋位分(子, 位) += 控1位/2;
  //*/

  //*37兵卒
  子.兵种 = 卒;
  位.纵 = 3;
  位.横 = 2;
  棋位分(子, 位) += 20;
  位.横 = 6;
  棋位分(子, 位) += 20;

  子.阵营 = 红方;
  位.纵 = 6;
  棋位分(子, 位) -= 20;
  位.横 = 2;
  棋位分(子, 位) -= 20; //*/

  红减黑分数 = 0;
  for(位.纵 = 0; 位.纵 <= 9; ++位.纵) {
    for(位.横 = 0; 位.横 <= 8; ++位.横) {
      for(子.阵营 = 1; 子.阵营 <= 2; ++子.阵营) {
        for(子.兵种 = 1; 子.兵种 <= 7; ++子.兵种) {
          红减黑分数 += 棋位分(子, 位);
        }
      }
    }
  }
  if(红减黑分数 != 0) {
    写<<"初始化审局分数数组错误";
    cin.get();
  }
}
#define 走法静态分(走法) (兵种分[取棋子(走法.终).兵种])

空型 设置排序分(char 深度, char 数量) {
  备份杀手分[2] = 历史分(杀手启发[深度][2]);
  备份杀手分[1] = 历史分(杀手启发[深度][1]);
  备份杀手分[0] = 历史分(杀手启发[深度][0]);
  历史分(杀手启发[深度][2]) = 历史分上限-5;
  历史分(杀手启发[深度][1]) = 历史分上限-4;
  历史分(杀手启发[深度][0]) = 历史分上限-3;

  备份置换分[2] = 历史分(置换表启发[深度][2]);
  备份置换分[1] = 历史分(置换表启发[深度][1]);
  备份置换分[0] = 历史分(置换表启发[深度][0]);
  历史分(置换表启发[深度][2]) = 历史分上限-2;
  历史分(置换表启发[深度][1]) = 历史分上限-1;
  历史分(置换表启发[深度][0]) = 历史分上限;

  for(字节 下标 = 0; 下标 < 数量; ++下标) {
    走法 &暂 = 走法列表[深度][下标];
    if(暂.排序分 <= 历史分上限) {
      暂.排序分 = 历史分(暂);
    }
  }

  历史分(杀手启发[深度][0]) = 备份杀手分[0];
  历史分(杀手启发[深度][1]) = 备份杀手分[1];
  历史分(杀手启发[深度][2]) = 备份杀手分[2];

  历史分(置换表启发[深度][0]) = 备份置换分[0];
  历史分(置换表启发[深度][1]) = 备份置换分[1];
  历史分(置换表启发[深度][2]) = 备份置换分[2];
}

空型 设置吃子排序分(char 深度, char 数量) {
  for(字节 下标 = 0; 下标 < 数量; ++下标) {
    走法 &暂 = 走法列表[深度][下标];
    暂.排序分 = 走法静态分(暂);
  }
}

空型 选择一个走法(char 深度, char 数量, char 开始下标) {
  字节 下标 = 开始下标+1,
  最高下标 = 开始下标;
  auto 最高分 = 走法列表[深度][开始下标].排序分;
  for(; 下标 < 数量; ++下标) {
    走法 &暂 = 走法列表[深度][下标];
    如果(暂.排序分 > 最高分) {
      最高分 = 暂.排序分;
      最高下标 = 下标;
    }
  }
  如果(最高下标 != 开始下标) {
    /*走法 暂 = 走法列表[深度][最高下标];
    for(下标 = 最高下标; 下标 > 开始下标; --下标) {
      走法列表[深度][下标] = 走法列表[深度][下标-1];
    }
    走法列表[深度][开始下标] = 暂;
    返回;*/
    交换(走法列表[深度][开始下标],
      走法列表[深度][最高下标]);
  }
}

#define 宏走棋(走法) \
棋子 被吃棋子=局面[走法.终.纵][走法.终.横],移动棋子=局面[走法.起.纵][走法.起.横]; \
auto 备份未吃子步数=未吃子步数;\
如果(被吃棋子.阵营!=空){--棋子数量;未吃子步数=0;}否则{++未吃子步数;}\
局面[走法.起.纵][走法.起.横]=空棋子; \
局面[走法.终.纵][走法.终.横]=移动棋子; \
局面键[一维坐标[走法.起.纵][走法.起.横]]=空; \
局面键[一维坐标[走法.终.纵][走法.终.横]]=棋值(移动棋子,红黑兵种); \
局面键[90]=反转阵营(局面键[90]);\
Zobrist局面键 ^= Zobrist哈希数组[棋值(移动棋子,红黑兵种)][走法.起.纵][走法.起.横]^Zobrist哈希数组[棋值(移动棋子,红黑兵种)][走法.终.纵][走法.终.横]^Zobrist哈希数组[棋值(被吃棋子,红黑兵种)][走法.终.纵][走法.终.横];\
Zobrist局面验 ^= Zobrist校验数组[棋值(移动棋子,红黑兵种)][走法.起.纵][走法.起.横]^Zobrist校验数组[棋值(移动棋子,红黑兵种)][走法.终.纵][走法.终.横]^Zobrist校验数组[棋值(被吃棋子,红黑兵种)][走法.终.纵][走法.终.横];\
红减黑分数+=棋位分(移动棋子, 走法.终)-棋位分(移动棋子, 走法.起)-棋位分(被吃棋子, 走法.终);

#define 宏悔棋(走法) \
局面[走法.起.纵][走法.起.横] = 移动棋子;\
局面[走法.终.纵][走法.终.横] = 被吃棋子;\
局面键[一维坐标[走法.起.纵][走法.起.横]] = 棋值(移动棋子, 红黑兵种);\
局面键[一维坐标[走法.终.纵][走法.终.横]] = 棋值(被吃棋子, 红黑兵种);\
局面键[90] = 走棋方;\
Zobrist局面键 = 备份键;\
Zobrist局面验 = 暂存.验;\
红减黑分数 = 备份;未吃子步数=备份未吃子步数;\
棋子数量 = 暂存.棋子数量;

无符号 int 局面数量, 预期深度;
int 各层走法数量[100];
bool 时间到;
int 静态搜索(int 阿尔法, int 贝塔, 正字节 现在深度, char 走棋方) {
  int 分数 = 审局(走棋方)-各层走法数量[现在深度-1]-各层空头分[现在深度-1]-各层威胁保护分[现在深度-1];
  if(分数 >= 贝塔 或 现在深度 > 99) {
    返回 分数;
  }
  各层走法数量[现在深度] = 获取走法(走棋方, 现在深度);
  如果(各层走法数量[现在深度] < 1) {
    返回 输+现在深度;
  }否则 如果(取棋子(走法列表[现在深度][0].终).兵种 == 将) {
    返回 赢-现在深度;
  }
  分数 += 各层走法数量[现在深度]+各层空头分[现在深度]+各层威胁保护分[现在深度];
  if(分数 >= 贝塔) {
    返回 分数;
  }
  char 对方 = 反转阵营(走棋方),
  受制 = 0;
  int 最优值 = 分数,
  备份 = 红减黑分数;
  if(分数 > 阿尔法) {
    阿尔法 = 分数;
  }
	
  棋子 移动棋子,
  被吃棋子;
  设置吃子排序分(现在深度, 各层走法数量[现在深度]);

  for(char 走法下标 = 0; 走法下标 < 各层走法数量[现在深度]; ++走法下标) {
    选择一个走法(现在深度, 各层走法数量[现在深度], 走法下标);
    走法 &走法 = 走法列表[现在深度][走法下标];

    被吃棋子 = 局面[走法.终.纵][走法.终.横];
    if(被吃棋子.阵营 == 对方) {
      移动棋子 = 局面[走法.起.纵][走法.起.横];

      //走棋
      局面[走法.起.纵][走法.起.横] = 空棋子;
      局面[走法.终.纵][走法.终.横] = 移动棋子;
      红减黑分数 += -棋位分(移动棋子, 走法.起)+棋位分(移动棋子, 走法.终)-棋位分(被吃棋子, 走法.终);

      //++局面数量;
      分数 = -静态搜索(-贝塔, -阿尔法, 现在深度+1, 对方);

      //悔棋
      局面[走法.起.纵][走法.起.横] = 移动棋子;
      局面[走法.终.纵][走法.终.横] = 被吃棋子;
      红减黑分数 = 备份;
    } else {
      //continue;
      break;
    }
    if(分数 >= 贝塔) {
      返回 分数;
    }
    if(分数 > 最优值) {
      最优值 = 分数;
      if(分数 > 阿尔法) {
        阿尔法 = 分数;
      }
    }
  }
  返回 最优值;
}

int 是否绝杀(正字节 现在深度, char 走棋方) {
  if(现在深度 >= 2) {
    返回 0;
  }
  int 分数,
  最优值 = 输;
  棋子 移动棋子,
  被吃棋子;
  char 走法数量 = 获取走法(走棋方, 现在深度),
  对方 = 反转阵营(走棋方);
  如果(走法数量 < 1) {
    返回 输+现在深度;
  }否则 如果(取棋子(走法列表[现在深度][0].终).兵种 == 将) {
    返回 赢-现在深度;
  }

  for(char 走法下标 = 0; 走法下标 < 走法数量; ++走法下标) {
    走法 &走法 = 走法列表[现在深度][走法下标];
    被吃棋子 = 局面[走法.终.纵][走法.终.横];
    移动棋子 = 局面[走法.起.纵][走法.起.横];

    //走棋
    局面[走法.起.纵][走法.起.横] = 空棋子;
    局面[走法.终.纵][走法.终.横] = 移动棋子;

    //递归
    分数 = -是否绝杀(现在深度+1, 对方);

    //悔棋
    局面[走法.起.纵][走法.起.横] = 移动棋子;
    局面[走法.终.纵][走法.终.横] = 被吃棋子;

    if(分数 > 必杀) {
      返回 分数;
    }
    if(分数 > 最优值) {
      最优值 = 分数;
    }
  }
  返回 最优值;
}

struct 蒙特卡洛树节点 {
  无符号 int 模拟次数 = 0;
  float 获胜次数 = 0;
};
map < 字符串, 蒙特卡洛树节点 > 蒙特卡洛树;
#define 选择 0
#define 探索 1
#define 扩展 2
#define  保存退出()\
蒙特卡洛树[局面键]=暂存; \
返回 暂存;

auto 蒙特卡洛树搜索(字节 现在深度, 字节 模式) {}

#define 低于预期 0
#define 符合预期 1
#define 高于预期 2
#define 杀或被杀 4


unordered_map < 字符串, 字节 > 历史局面;
unordered_map < 字符串, 搜索信息 > 置换表;

struct 变例 {
  无符号 char 走法数量 = 0;
  走法 走法路线[68];
};
字节  最好下标;

long 哈希冲突次数 = 0, 哈希探测次数;
#define 删除历史局面() 历史局面.erase(局面键);
#define 加入历史局面() 历史局面[局面键]=1;

int 阿尔法贝塔搜索(int 阿尔法, int 贝塔, 正字节 现在深度, char 走棋方, 字节 剩余深度) {
  ++局面数量;
  //循环局面
  如果(现在深度 > 0 且 历史局面.find(局面键) != 历史局面.end()) {
    返回 审局(走棋方)/2;
    返回 0;
    返回 静态搜索(阿尔法, 贝塔, 现在深度, 走棋方);
  }

  //置换表避免重复搜索
  uint32_t 置换表下标 = (走棋方-1)*置换表长度+(Zobrist局面键&(置换表长度-1));
  bool 散列命中 = 假;
  ++哈希探测次数;
  搜索信息  暂存 = Zobrist置换表深度优先[置换表下标];
  char 查表次数 = 1;
  查表:
  如果(现在深度 > 0 且 暂存.验 == Zobrist局面验) {
    散列命中 = 真;

    如果(暂存.深度 >= 剩余深度 且
      (暂存.类型 == 符合预期 or
        (暂存.类型 == 高于预期 且 暂存.分数 >= 贝塔) or
        (暂存.类型 == 低于预期 且 暂存.分数 <= 阿尔法))) {
      ++置换次数;
      如果(暂存.分数 > 必杀) {
        返回 暂存.分数-现在深度;
      }else 如果(暂存.分数 < -必杀) {
        返回 暂存.分数+现在深度;
      }
      返回 暂存.分数;
    }如果(查表次数 < 2 且 暂存.深度 > 0) {
      //*
      置换表启发[现在深度][2] = 暂存.第三走法;
      置换表启发[现在深度][1] = 暂存.第二走法;
      置换表启发[现在深度][0] = 暂存.最好走法; //*/
      /*杀手启发[现在深度][2] = 暂存.第三走法;
      杀手启发[现在深度][1] = 暂存.第二走法;
      杀手启发[现在深度][0] = 暂存.最好走法;*/
      ++置换启发次数;
    }
    goto 再查;
  }否则 {
    如果(暂存.验 != 0) {
      ++哈希冲突次数; //显名值(暂存.验)显名值(Zobrist局面验)
    }
    再查:
    if(查表次数 < 2) {
      暂存 = Zobrist置换表[置换表下标];
      ++查表次数;
      goto 查表;
    }
    暂存.验 = Zobrist局面验;
  }

  auto 备份键 = Zobrist局面键;
  暂存.棋子数量 = 棋子数量;
  char 类型 = 低于预期;
  if(剩余深度 <= 0 或 (阿尔法 > 必杀 且 赢- 阿尔法 <= 现在深度) 或 (贝塔<-必杀 且 -必杀-贝塔 <= 现在深度)) {
    //++局面数量;
    //返回 审局(走棋方);
    返回 静态搜索(阿尔法, 贝塔, 现在深度, 走棋方);
    /*暂存.分数=静态搜索(阿尔法,贝塔,现在深度,走棋方);
            暂存.深度=0;
            如果(暂存.分数>=贝塔){
                暂存.类型=高于预期;
            }否则 如果(暂存.分数>阿尔法){
                暂存.类型=符合预期;}
            //置换表[局面键]=暂存;
            Zobrist置换表[Zobrist局面键]=暂存;
            ++保存次数;
            返回 暂存.分数;*/
  }

  字节 对方 = 反转阵营(走棋方);
  int 最优值 = 输,
  备份 = 红减黑分数,
  分数,
  突破;
  字节 被将 = 0,
  吃子;
  /*
    if(审局(走棋方)<阿尔法-兵种分[车]) {
      分数=静态搜索(阿尔法-1, 阿尔法, 现在深度, 走棋方);
      如果(分数<阿尔法)
      返回 分数;
    }
    */
  if(现在深度 > 0) {
    各层走法数量[现在深度] = 获取走法(走棋方, 现在深度);
  }//else if(剩余深度 == 1)  设置排序分(现在深度, 各层走法数量[现在深度]);

  如果(各层走法数量[现在深度] < 1) {
    返回 输+现在深度;
  }否则 如果(取棋子(走法列表[现在深度][0].终).兵种 == 将) {
    //吃将帅
    返回 赢-现在深度;
  }
  设置排序分(现在深度, 各层走法数量[现在深度]);

  加入历史局面()

  //*空着裁剪
  if(//
  假 且 
  可空着 且 现在深度 > 0) {
    //字节 空着深度 = 最小(剩余深度/2,剩余深度-1-2);
    //
    字节 空着深度 = 剩余深度-1-2;
    //if(空着深度>1)空着深度=1;
    可空着 = 假;
    局面键[90] = 对方;
    分数 = -阿尔法贝塔搜索(-贝塔, -贝塔+1, 现在深度+1, 对方, 空着深度);
    局面键[90] = 走棋方;
    可空着 = 真;

    如果(//0 且
      分数 < -必杀) {
      //被将军
      被将 = 1;
      //显名值(现在深度)显名值(分数)等待回车()
    }
    if(分数 >= 贝塔) {
      if(假 且
        空着深度 >= 2) {
        可空着 = 假;
        分数 = 阿尔法贝塔搜索(贝塔-1, 贝塔, 现在深度, 走棋方, 1);
        可空着 = 真;
      }
      if(分数 >= 贝塔) {
        删除历史局面()
        返回 分数;
      }
    }
  }
  //*/

  //auto 加分=pow(2,剩余深度);
  //auto 加分 = 剩余深度*剩余深度;
  //auto 加分=剩余深度;
  //
  auto 加分 = 1;
  //auto 加分=各层走法数量[现在深度];
  棋子 移动棋子,
  被吃棋子;
  //走法 走法;
  字节 走法下标;
  //  如果(被将 且 剩余深度 == 1)剩余深度+=1;
  走法 最好走法;
  auto 没搜完 = 假;
  for(走法下标 = 0; 走法下标 < 各层走法数量[现在深度]; ++走法下标) {
    选择一个走法(现在深度, 各层走法数量[现在深度], 走法下标);
    走法 &走法 = 走法列表[现在深度][走法下标];

    //走棋
    宏走棋(走法)

    if(//假 且
      pvs 且
      类型 == 符合预期
      //走法下标>0
    ) {
      分数 = - 阿尔法贝塔搜索(-阿尔法-1, -阿尔法, 现在深度+1, 对方, 剩余深度-1);
      if(阿尔法 < 分数 且 分数 < 贝塔) {
        突破 = 分数;
        分数 = - 阿尔法贝塔搜索(-贝塔, -阿尔法, 现在深度+1, 对方, 剩余深度-1);
        if(分数 < 突破) {
          ++pvs假突破次数;
          //写<<"错误";显名值(阿尔法)显名值(突破)显名值(分数)
          //cin.get();
        }
      }
    } else {
      分数 = - 阿尔法贝塔搜索(- 贝塔, - 阿尔法, 现在深度+1, 对方, 剩余深度-1);
    }
    没搜完 = 时间到;
    //还原
    宏悔棋(走法)

    if(没搜完) {
      如果(现在深度 == 0) {
        写<<"info string 第"<<走法下标+1<<"个走法超时";
        换行()
      }
      if(走法下标 == 0
      ) {
        //第一个走法超时
        if(散列命中) {
          Zobrist置换表[置换表下标] = 暂存;
          ++保存次数;
        }
        删除历史局面()
        返回 分数;
      }
      break;
    }
    /*如果(现在深度 == 0) {
          //写<<取走法文本(走法); 显名值(分数)
        }*/
    if(分数 > 最优值) {
      如果(现在深度 == 0) {
        最好下标 = 走法下标;
      }
      最优值 = 分数;
      最好走法 = 走法;
      if(分数 >= 贝塔) {
        如果(历史分(走法) < 历史分上限
          -9)
        历史分(走法) += 加分;
        ++历史启发次数;
        如果(! 走法相等吗(走法, 杀手启发[现在深度][0])) {
          如果(走法相等吗(走法, 杀手启发[现在深度][1])) {
            ++杀手启发次数;
            调整杀手:
            //
            杀手启发[现在深度][1] = 杀手启发[现在深度][0];
            //
            杀手启发[现在深度][0] = 走法;
          }else {
            杀手启发[现在深度][2] = 杀手启发[现在深度][1]; goto 调整杀手;
          }
        }
        类型 = 高于预期;
        break;
        //goto 保存;
      }

      if(分数 > 阿尔法) {
        阿尔法 = 分数;
        类型 = 符合预期;
      }否则 如果(//分数 < 阿尔法 且
        历史分(走法) > //0
        INT_MIN
      ) {
        --历史分(走法);
      }
    }
  }
  /*
  如果(!没搜完) {
          ++历史分(最好走法);
          ++历史启发次数;
      }//*/
  保存:
  暂存.类型 = 类型;
  暂存.深度 = (没搜完 ? 剩余深度-1: 剩余深度);

  如果(! 走法相等吗(最好走法, 暂存.最好走法)) {
    如果(走法相等吗(最好走法, 暂存.第二走法)) {
      调整走法:
      暂存.第二走法 = 暂存.最好走法;
      暂存.最好走法 = 最好走法;
    }else {
      暂存.第三走法 = 暂存.第二走法; goto 调整走法;
    }
  }
  如果(最优值 > 必杀) {
    //暂存.类型 = 杀或被杀;
    暂存.分数 = 最优值+ 现在深度;
  }否则 如果(最优值 < -必杀) {
    //暂存.类型 = 杀或被杀;
    暂存.分数 = 最优值- 现在深度;
  }否则 {
    暂存.分数 = 最优值;
  }
  //如果(暂存.类型==符合预期) 置换表[局面键]=暂存;
  Zobrist置换表[置换表下标] = 暂存;
  ++保存次数;
  if(剩余深度 > Zobrist置换表深度优先[置换表下标].深度) {
    Zobrist置换表深度优先[置换表下标] = 暂存;
    ++保存次数;
  }
  退出:
  删除历史局面()
  返回 最优值;
}
//#undef 走法

常量 字符串 零到九[] = {
  "零",
  "一",
  "二",
  "三",
  "四",
  "五",
  "六",
  "七",
  "八",
  "九"
};
字符串 红黑数字文本(字节 阵营, 正字节 数字, bool 是横) {
  返回 (数字 <= 9 ?
    (阵营 == 黑方 ?
      to_string(数字):
      零到九[是横 ? 10-数字: 数字]):
    "错误数字");
}
字符串 取走法文本(走法 走法) {
  棋子 子 = 取棋子(走法.起);
  if((!走法在棋盘(走法)) 或 子.阵营 == 空) {
    没完 = 假;
    返回 "错误走法";
  }
  字符串 着法 = {};
  字节 同子数 = 0;
  位置 位 = 走法.起;
  for(位.纵 = 0; 位.纵 < 10; 位.纵++) {
    如果(取棋子(位).阵营 == 子.阵营 且 取棋子(位).兵种 == 子.兵种) {
      如果(位.纵 != 走法.起.纵) {
        着法 += ((位.纵 < 走法.起.纵) == (子.阵营 == 红方) ? "后": "前");
        同子数++;
        break;
      }
      否则 如果(同子数 > 0) {}
    }
  }
  着法 += 棋值(子, 棋子文本)+(同子数 > 0 ? "": 红黑数字文本(子.阵营, 走法.起.横+1, 真));
  if(走法.起.纵 == 走法.终.纵) {
    着法 += "平";
  } else if((走法.起.纵 < 走法.终.纵) == (子.阵营 == 黑方)) {
    着法 += "进";
  }
  else {
    着法 += "退";
  }
  if(走法.起.横 == 走法.终.横) {
    着法 += 红黑数字文本(子.阵营, 绝对值(走法.起.纵-走法.终.纵), 假);
  }
  else {
    着法 += 红黑数字文本(子.阵营, 走法.终.横+1, 真);
  }
  返回 着法;
}
字节 uci走法[4];

auto 走法转uci(走法& 走) {
  uci走法[0] = 走.起.横+'a';
  uci走法[1] = '9'-走.起.纵;
  uci走法[2] = 走.终.横+'a';
  uci走法[3] = '9'-走.终.纵;
  返回 uci走法;
}

空型 显示变例(字节 下标) {
  if(下标 < 预期深度) {
    //auto 查找结果=置换表.find(局面键);
    //if(查找结果!=置换表.end()) {
    搜索信息 暂存;
    auto 走棋方 = 该走方;
    auto 置换表下标 = (走棋方-1)*置换表长度+(Zobrist局面键%置换表长度);

    如果(置换表下标 >= 置换表长度*2) {
      写<<"下标错误";
      等待回车()返回;
    }
    暂存 = Zobrist置换表深度优先[置换表下标];
    重复(2,
      如果(暂存.验 == Zobrist局面验) {
        //搜索信息 暂存=(*查找结果).second ;
        如果(暂存.深度 <= 0)返回;
        走法 走法 = 暂存.最好走法;
        如果(下标 == 0)对策 = 走法;
        //如果(暂存.类型!=符合预期){返回;}
        /*
      写<<下标+1<<"(";
      //显示走法(走法)
      写<<取走法文本(走法)<<") ";
*/写<<" "<<走法转uci(走法);
        棋子 被吃棋子 = 局面[走法.终.纵][走法.终.横],
        移动棋子 = 局面[走法.起.纵][走法.起.横];
        auto 备份键 = Zobrist局面键;

        局面[走法.起.纵][走法.起.横] = 空棋子;
        \
        局面[走法.终.纵][走法.终.横] = 移动棋子;
        \
        Zobrist局面键 ^= Zobrist哈希数组[棋值(移动棋子, 红黑兵种)][走法.起.纵][走法.起.横]^Zobrist哈希数组[棋值(移动棋子, 红黑兵种)][走法.终.纵][走法.终.横]^Zobrist哈希数组[棋值(被吃棋子, 红黑兵种)][走法.终.纵][走法.终.横];
        Zobrist局面验 ^= Zobrist校验数组[棋值(移动棋子, 红黑兵种)][走法.起.纵][走法.起.横]^Zobrist校验数组[棋值(移动棋子, 红黑兵种)][走法.终.纵][走法.终.横]^Zobrist校验数组[棋值(被吃棋子, 红黑兵种)][走法.终.纵][走法.终.横];
        该走方 = 反转阵营(该走方);

        显示变例(下标+1); //递归

        //悔棋
        该走方 = 走棋方;
        局面[走法.起.纵][走法.起.横] = 移动棋子;
        局面[走法.终.纵][走法.终.横] = 被吃棋子;
        Zobrist局面键 = 备份键;
        Zobrist局面验 = 暂存.验;
        返回;
      }else 暂存 = Zobrist置换表[置换表下标];)
  }
}

#define 是否结束() \
分数=是否绝杀(0,该走方);\
如果(绝对值(分数)>必杀) \
{写<<"绝杀吴姐,"<<((该走方==红方) == (分数>必杀) ? "红" : "黑")<<"方胜!";换行()break;}
空型 显示所有走法(字节 走棋方) {
  写<<"现在可走：-1(程序互搏) 0(退出游戏) ";
  int 现在深度 = 0,
  走法数量 = 获取走法(走棋方, 现在深度);
  走法 走法;
  位置 起;
  for(char 走法下标 = 0; 走法下标 < 走法数量; ++走法下标) {
    走法 = 走法列表[现在深度][走法下标];
    如果(走法.起.纵 != 起.纵 或 走法.起.横 != 起.横)换行()//不同位置的棋子换行输出
    写<<走法下标+1<<"("<<取走法文本(走法)<<") ";
    起 = 走法.起;
  }

  字符串 输入;
  int 走法序号;

  do {
    换行()
    写<<"你选择:";
    读>>输入;

    走法序号 = stoi(输入);
    //显名值(走法序号)
    如果(走法序号 < -1 或 走法序号 > 走法数量) {
      走法错误 = 真;

      写<<"走法错误!"; //<<走法数量;
      //返回;
    } else {

      如果(输入 == "-1") {
        人机对弈 = 假;
        返回;
      }
      如果(输入 == "0") {
        没完 = 假;
        返回;
      }走法错误 = 假;
      走法 = 走法列表[现在深度][走法序号-1];
      写<<取走法文本(走法);
      换行()
      加入历史局面()
      宏走棋(走法)
      该走方 = 反转阵营(该走方);
      显示局面();
    }
  } while(走法错误);
}

int MTDF(int 猜测, int 深度) {
  int 分数,
  贝塔,
  顶,
  底;
  分数 = 猜测;
  顶 = 赢;
  底 = 输;
  换行()写<<"MTDF搜索";
  //显名值(深度)
  do {
    贝塔 = (分数 == 底 ? 分数 + 1: 分数);
    分数 = 阿尔法贝塔搜索(贝塔 - 1, 贝塔, 0, 该走方, 深度);
    显名值(分数)
    (分数 < 贝塔 ? 顶: 底) = 分数;
  } while (底 < 顶 且 !时间到);
  return 分数;
}

int 最大偏差 = 0;
int 期望搜索(int 猜测, int 深度) {
  int 顶,
  底,
  分数;
  int 第几次 = 1;
  顶 = 猜测+1;
  底 = 猜测-1;
  for(; 第几次 <= 2  且 !时间到; ++第几次) {
    分数 = 阿尔法贝塔搜索(底, 顶, 0, 该走方, 深度);
    if(分数 >= 顶) {
      底 = 分数-1;
      顶 = 赢;
    }
    else if(分数 <= 底) {
      顶 = 分数+1;
      底 = 输;
    }
    else {
      break;
    }
  }
  返回 分数;
}

void 计时() {
  auto 线程开始 = 开始时间;
  std::this_thread::sleep_for(std::chrono::milliseconds(限时毫秒));
  //写<<"时间到"<<转毫秒(取现在系统时间()-开始时间) ; 换行()
  如果(线程开始 == 开始时间)时间到 = 真;
}

void 局面设置(常量 字符串& fen) {
  整数 下标 = 0,
  上限;
  位置 位;
  bool 没空格 = 真;
  棋子数量 = 0;
  红减黑分数 = 0;
  Zobrist局面键 = 0;
  Zobrist局面验 = 未吃子步数 = 0;
  历史局面.clear();
  for(auto 字: fen) {
    如果(字 == ' ') {
      没空格 = 假; continue;
    }
    如果(没空格) {
      如果(字 == '/') {
        ++位.纵; 位.横 = 0; continue;
      }
      如果('1' <= 字 且 字 <= '9') {
        上限 = 字-'0'+下标;
        for(; 下标 < 上限; ++下标) {
          局面键[下标] = 空;
          局面[位.纵][位.横].阵营 = 空;
          局面[位.纵][位.横].兵种 = 空;
          ++ 位.横;
        }
        continue;
      }否则
      如果(字 == 'r') {
        局面键[下标] = 黑车;
      }否则
      如果(字 == 'n') {
        局面键[下标] = 黑马;
      }否则
      如果(字 == 'b') {
        局面键[下标] = 黑象;
      }否则
      如果(字 == 'a') {
        局面键[下标] = 黑士;
      }否则
      如果(字 == 'k') {
        局面键[下标] = 黑将;
      }否则
      如果(字 == 'c') {
        局面键[下标] = 黑炮;
      }否则
      如果(字 == 'p') {
        局面键[下标] = 黑卒;
      }否则

      如果(字 == 'R') {
        局面键[下标] = 红车;
      }否则
      如果(字 == 'N') {
        局面键[下标] = 红马;
      }否则
      如果(字 == 'B') {
        局面键[下标] = 红象;
      }否则
      如果(字 == 'A') {
        局面键[下标] = 红士;
      }否则
      如果(字 == 'K') {
        局面键[下标] = 红将;
      }否则
      如果(字 == 'C') {
        局面键[下标] = 红炮;
      }否则
      如果(字 == 'P') {
        局面键[下标] = 红卒;
      }否则 continue;
      ++棋子数量;
      Zobrist局面键 ^= Zobrist哈希数组[局面键[下标]][位.纵][位.横];
      Zobrist局面验 ^= Zobrist校验数组[局面键[下标]][位.纵][位.横];
      局面[位.纵][位.横].阵营 = 取阵营(局面键[下标]);
      局面[位.纵][位.横].兵种 = 取兵种(局面键[下标]);
      红减黑分数 += 棋位分(取棋子(位), 位);
      ++下标;
      ++位.横;
    }否则 {
      如果(字 == 'b') {
        该走方 = 黑方;
      }否则 {
        该走方 = 红方;
      }
      局面键[下标] = 该走方;
      return;
    }
  }
}

走法 UCI转走法(字符串& uci走法) {
  走法 走;
  走.起.横 = uci走法[0]-'a';
  走.起.纵 = '9'-uci走法[1];
  走.终.横 = uci走法[2]-'a';
  走.终.纵 = '9'-uci走法[3];
  返回 走;
}
void 位置(istringstream& is) {
  走法 走法;
  字符串 标志,fen;

  is >> 标志;
  if (标志 == "startpos") {
    fen = 开局FEN;
    is >> 标志; //如果存在，则消耗 'moves' 标记
  } else if (标志 == "fen") {
    while (is >> 标志 且 标志 != "moves")
    fen += 标志 + " ";
  }else return;

  局面设置(fen);

  //如果有棋步列表，解析它。
  while (is >> 标志) {
    走法 = UCI转走法(标志);
    加入历史局面()
    宏走棋(走法); 该走方 = 局面键[90];
  }

  //显示局面();
}

int 限制深度 = 99;
bool 在思考 = 假,
后台思考 = 假;

void 迭代深化() {
  在思考 = 真;
  各层走法数量[0] = 获取走法(该走方, 0);
  整数 分数,猜测;
  //猜测 = 审局(该走方);
  for(预期深度 = 1; 预期深度 <= 限制深度; 预期深度 += 1) {
    最好下标 = -1;
  //
    分数 = 阿尔法贝塔搜索(输, 赢, 0, 该走方, 预期深度);
    //    分数 = 期望搜索(猜测, 预期深度);
    //分数=MTDF(猜测,预期深度);
    if(最好下标 > -1) {
      走法列表[0][最好下标].排序分 = 历史分上限+预期深度;
      写<<"info string 第"<<最好下标+1<<"个走法最好";
      换行()}

    猜测 = 分数;
    用时毫秒 = 转毫秒(取现在系统时间()-开始时间);
    如果(用时毫秒 <= 0) 用时毫秒 = 1;

    //换行()//显名值(人机对弈)
    写<<"info depth "<<预期深度<<" score cp "<< 分数
    <<" nodes "<<局面数量<<" time "
    <<用时毫秒<<" nps "<<局面数量/(用时毫秒/1000.0);
    写<<" pv";
    显示变例(0);
    换行()

    if(时间到
      //或 (绝对值(分数) > 必杀 且 局面数量 > 预期深度)
    )break;
  }
  写<<"bestmove "<<走法转uci(对策); 换行()
  /*
  加入历史局面()
  宏走棋(对策)
  该走方 = 反转阵营(该走方);
  显示局面();*/

  在思考 = 假;
}
void go(istringstream& is) {
  //开始时间 = clock();
  开始时间 = 取现在系统时间();
  时间到 = 真;
  while(在思考) {}

  时间到 = 假;
  pvs假突破次数 = 保存次数 = 置换次数 = 历史启发次数 = 杀手启发次数 = 置换启发次数 = 局面数量 = 哈希冲突次数 = 哈希探测次数 = 0;
  限制深度 = 99;
  // 限时毫秒 = 60*60*1000;
  限时毫秒 = 1*1000;
  后台思考 = 假;
  string 标志;
  while (is >> 标志) {
    if (标志 == "searchmoves") {
      // 必须是行上的最后一个命令
      while (is >> 标志) {}
      //限制.search移动s.push_back(UCI::终_移动(pos, 标志));
    }
    else if (标志 == "wtime"); //is >> 限制.time[WHITE];
    else if (标志 == "btime"); //is >> 限制.time[BLACK];
    else if (标志 == "winc"); // is >> 限制.inc[WHITE];
    else if (标志 == "binc"); // is >> 限制.inc[BLACK];
    else if (标志 == "movestogo");
    else if (标志 == "depth") {
      is >> 限制深度; 限时毫秒 = 60*60*1000;
    }
    else if (标志 == "nodes");
    else if (标志 == "movetime") {
      is >> 限时毫秒;
    }
    else if (标志 == "mate");
    else if (标志 == "perft");
    else if (标志 == "infinite" 或 标志 == "无限")限时毫秒 = 60*60*1000;
    else if (标志 == "ponder") {
      后台思考 = 真; 限时毫秒 = 60*60*1000;
    }
  }
  thread(计时).detach();
  thread(迭代深化).detach();
}

int main(int 参数数量, char* 参数文本[]) {
  //*
  整数 测试 = 3,检查下标[2];
  测试=检查下标[测试];
  遍历(3, 测试 = 检查下标[下标]; )//*/

  ios::sync_with_stdio(真);
  //无限循环(写<<"老子道德经反复思考";)
  初始化();
  开局赋值();
  //
  显示局面();

  字符串 命令行,标志;
  for (int 下标 = 1; 下标 < 参数数量; ++下标) {
    命令行 += 字符串(参数文本[下标]) + " ";
  }

  do {
    if (参数数量 == 1 且 !getline(cin, 命令行)) {
      命令行 = "quit";
    }

    istringstream is(命令行);
    标志.clear();
    is >> skipws >> 标志; //skipws忽略前空白字符

    if (标志 == "uci") {
      写 << "id name " << "象棋方程组"
      << "\n" <<"id author 方程组"
      << "\n" "uciok" << endl;
    }
    否则 if (标志 == "quit" 或 标志 == "stop" 或 标志 == "退") {
      时间到 = 真;
    }
    else if (标志 == "ponderhit") {
      //后台思考命中
      时间到 = 真;
      while(在思考) {}
      后台思考 = 假;

      加入历史局面()
      宏走棋(对策)
      该走方 = 反转阵营(该走方);
    }
    else if (标志 == "setoption") {}//设置选项(is);
    else if (标志 == "go") {
      go(is);
    }
    else if (标志 == "position") {
      位置(is);
    }
    else if (标志 == "fen" || 标志 == "startpos") {
      is.seekg(0);
      位置(is);
    }
    else if (标志 == "ucinewgame") {
      时间到 = 真;
      while(在思考) {}
      开局赋值();
    } 
    else if (标志 == "isready") 
			写 << "readyok" << endl;
    else if (!标志.empty() 且 标志[0] != '#')
			写 << "未知命令: '" << 命令行 << "'." << endl;

  } while (标志 != "quit" 且 参数数量 == 1 且 标志 != "退");

  返回 0;
}